<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Welcome to CLU’s documentation! &mdash; CLU  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="#" class="icon icon-home"> CLU
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Welcome to CLU’s documentation!</a></li>
<li><a class="reference internal" href="#module-clu.abstract">clu.abstract</a></li>
<li><a class="reference internal" href="#module-clu.all">clu.all</a></li>
<li><a class="reference internal" href="#module-clu.api">clu.api</a></li>
<li><a class="reference internal" href="#module-clu.application">clu.application</a></li>
<li><a class="reference internal" href="#module-clu.compilation">clu.compliation</a></li>
<li><a class="reference internal" href="#module-clu.config.abc">clu.config</a></li>
<li><a class="reference internal" href="#module-clu.csv">clu.csv</a></li>
<li><a class="reference internal" href="#module-clu.constants.consts">clu.constants</a></li>
<li><a class="reference internal" href="#module-clu.dicts">clu.dicts</a></li>
<li><a class="reference internal" href="#module-clu.dispatch">clu.dispatch</a></li>
<li><a class="reference internal" href="#module-clu.enums">clu.enums</a></li>
<li><a class="reference internal" href="#module-clu.exporting">clu.exporting</a></li>
<li><a class="reference internal" href="#module-clu.extending">clu.extending</a></li>
<li><a class="reference internal" href="#module-clu.fs.abc">clu.fs</a></li>
<li><a class="reference internal" href="#module-clu.importing.base">clu.importing</a></li>
<li><a class="reference internal" href="#module-clu.keyvalue">clu.keyvalue</a></li>
<li><a class="reference internal" href="#module-clu.mathematics">clu.mathematics</a></li>
<li><a class="reference internal" href="#module-clu.naming">clu.naming</a></li>
<li><a class="reference internal" href="#module-clu.predicates">clu.predicates</a></li>
<li><a class="reference internal" href="#module-clu.repl.ansi">clu.repl</a></li>
<li><a class="reference internal" href="#module-clu.repr">clu.repr</a></li>
<li><a class="reference internal" href="#module-clu.sanitizer">clu.sanitizer</a></li>
<li><a class="reference internal" href="#module-clu.scripts.ansicolors">clu.scripts</a></li>
<li><a class="reference internal" href="#module-clu.shelving">clu.shelving</a></li>
<li><a class="reference internal" href="#module-clu.stdio">clu.stdio</a></li>
<li><a class="reference internal" href="#module-clu.testing.pytest">clu.testing</a></li>
<li><a class="reference internal" href="#module-clu.typespace">clu.typespace</a></li>
<li><a class="reference internal" href="#module-clu.typology">clu.typology</a></li>
<li><a class="reference internal" href="#module-clu.version">clu.version</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">CLU</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
      <li>Welcome to CLU’s documentation!</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="welcome-to-clu-s-documentation">
<h1>Welcome to CLU’s documentation!<a class="headerlink" href="#welcome-to-clu-s-documentation" title="Permalink to this heading"></a></h1>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="module-clu.abstract">
<span id="clu-abstract"></span><h1>clu.abstract<a class="headerlink" href="#module-clu.abstract" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.AppName">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">AppName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.AppName" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.AsyncManagedContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">AsyncManagedContext</span></span><a class="headerlink" href="#clu.abstract.AsyncManagedContext" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.BaseDescriptor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">BaseDescriptor</span></span><a class="headerlink" href="#clu.abstract.BaseDescriptor" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.BasePath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">BasePath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basepath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.BasePath" title="Permalink to this definition"></a></dt>
<dd><p>A metaclass to assign a “basepath” class property,
extracted from a “basepath” class keyword, to a new
slotted type.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.CacheDescriptor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">CacheDescriptor</span></span><a class="headerlink" href="#clu.abstract.CacheDescriptor" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.abstract.CacheDescriptor.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.CacheDescriptor.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.Cloneable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">Cloneable</span></span><a class="headerlink" href="#clu.abstract.Cloneable" title="Permalink to this definition"></a></dt>
<dd><p>An abstract class representing something “clonable.” A cloneable
subclass need only implement the one method, “clone()” – taking no
arguments and returning a new instance of said class, populated
as a cloned copy of the instance upon which the “clone()” method
was called.</p>
<p>Implementors are at liberty to use shallow- or deep-copy methods,
or a mixture of the two, in creating these cloned instances.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.abstract.Cloneable.clone">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.Cloneable.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a cloned copy of this instance</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.DataDescriptor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">DataDescriptor</span></span><a class="headerlink" href="#clu.abstract.DataDescriptor" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.Descriptor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">Descriptor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.Descriptor" title="Permalink to this definition"></a></dt>
<dd><p>A simple, generic desciptor, wrapping one value, and storing its name</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.Format">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">Format</span></span><a class="headerlink" href="#clu.abstract.Format" title="Permalink to this definition"></a></dt>
<dd><p>An abstract class representing something that formats something
else. It only offers the one abstract method, “render(…)” at
this time.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.abstract.Format.render">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.Format.render" title="Permalink to this definition"></a></dt>
<dd><p>Render a string with respect to the Format instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.ManagedContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">ManagedContext</span></span><a class="headerlink" href="#clu.abstract.ManagedContext" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.MappingViewRepr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">MappingViewRepr</span></span><a class="headerlink" href="#clu.abstract.MappingViewRepr" title="Permalink to this definition"></a></dt>
<dd><p>A ReprWrapper class that simply returns the repr for a
“self._mapping” value – of which most MappingView types make use.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.abstract.MappingViewRepr.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.MappingViewRepr.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return the repr string for “self._mapping”</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.NamedDescriptor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">NamedDescriptor</span></span><a class="headerlink" href="#clu.abstract.NamedDescriptor" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.NonFormat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">NonFormat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.NonFormat" title="Permalink to this definition"></a></dt>
<dd><p>A “format” type whose “render(…)” method is a no-op.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.abstract.NonFormat.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.NonFormat.render" title="Permalink to this definition"></a></dt>
<dd><p>Return a string, unchanged</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.NonSlotted">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">NonSlotted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.NonSlotted" title="Permalink to this definition"></a></dt>
<dd><p>A metaclass that ensures its classes, and all subclasses,
will •not• use the “__slots__” optimization.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.ReprWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">ReprWrapper</span></span><a class="headerlink" href="#clu.abstract.ReprWrapper" title="Permalink to this definition"></a></dt>
<dd><p>ReprWrapper fills in a default template for __repr__ results,
based on a standard display including the type name and the
hex ID of the instance:</p>
<blockquote>
<div><p>TypeName( ••• ) &#64; 0xDEADBEEF</p>
</div></blockquote>
<p>… The “ ••• ” string gets filled in by a new abstract method,
“inner_repr()”, which subclasses must provide. This new method
takes no arguments and should return a string.</p>
<p>Example 1: Return the repr of a relevant sub-instance value:</p>
<blockquote>
<div><p>FlatOrderedSet((‘a’, ‘b’, ‘c’, ‘d’)) &#64; 0x115299650</p>
</div></blockquote>
<p>… Note that the parenthesized value is the repr of an internal
tuple value. The “inner_repr()” method returns something like
“repr(self.internal_tuple)”.</p>
<p>Example 2: Return some interesting meta-information:</p>
<blockquote>
<div><p>Env([prefix=“CLU_*”, namespaces=4, keys=13]) &#64; 0x115373690</p>
</div></blockquote>
<p>… Here the return value of “inner_repr()” is composed freely,
like any other repr-string, instead of delegated wholesale to
another objects repr value.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.abstract.ReprWrapper.inner_repr">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.ReprWrapper.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.Sanitizer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">Sanitizer</span></span><a class="headerlink" href="#clu.abstract.Sanitizer" title="Permalink to this definition"></a></dt>
<dd><p>A base format type, with a slot for a compiled regular expression.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.abstract.Sanitizer.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.Sanitizer.render" title="Permalink to this definition"></a></dt>
<dd><p>Render a string with respect to the Format instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.Slotted">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">Slotted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.Slotted" title="Permalink to this definition"></a></dt>
<dd><p>A metaclass that ensures its classes, and all subclasses,
will be slotted types.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.SlottedFormat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">SlottedFormat</span></span><a class="headerlink" href="#clu.abstract.SlottedFormat" title="Permalink to this definition"></a></dt>
<dd><p>A base format type, with a slot for a format-operation string.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.SlottedRepr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">SlottedRepr</span></span><a class="headerlink" href="#clu.abstract.SlottedRepr" title="Permalink to this definition"></a></dt>
<dd><p>A simple, default version of a ReprWrapper class that uses its
inheritance chain’s value for “__slots__” to build the repr
string for its instances</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.abstract.SlottedRepr.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.SlottedRepr.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Use the union of __slots__, defined across this classes’
inheritance chain, to build the instances’ repr string</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.Unhashable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">Unhashable</span></span><a class="headerlink" href="#clu.abstract.Unhashable" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.UnhashableMeta">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">UnhashableMeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.UnhashableMeta" title="Permalink to this definition"></a></dt>
<dd><p>A slotted metaclass that ensures its classes, and all
subclasses, will <em>not</em> be hashable types.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.abstract.ValueDescriptor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.abstract.</span></span><span class="sig-name descname"><span class="pre">ValueDescriptor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.abstract.ValueDescriptor" title="Permalink to this definition"></a></dt>
<dd><p>A descriptor whose repr-string tries to be a literal reflection
of its wrapped value</p>
</dd></dl>

</section>
<section id="module-clu.all">
<span id="clu-all"></span><h1>clu.all<a class="headerlink" href="#module-clu.all" title="Permalink to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="clu.all.import_all_modules">
<span class="sig-prename descclassname"><span class="pre">clu.all.</span></span><span class="sig-name descname"><span class="pre">import_all_modules</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basepath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exportername</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'exporter'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.all.import_all_modules" title="Permalink to this definition"></a></dt>
<dd><p>Import all modules that use the “clu.exporting.ExporterBase”
mechanism for listing and exporting their module contents,
for a given «basepath», «appname», and «exportername» – where:</p>
<blockquote>
<div><ul class="simple">
<li><p>“basepath” is the root path of a Python package;</p></li>
<li><p>“appname” is a valid module name within «basepath»; and</p></li>
<li><p>“exportername” is the name of the “Exporter” instances.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.all.import_clu_modules">
<span class="sig-prename descclassname"><span class="pre">clu.all.</span></span><span class="sig-name descname"><span class="pre">import_clu_modules</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.all.import_clu_modules" title="Permalink to this definition"></a></dt>
<dd><p>Import all CLU modules that use the “clu.exporting.Exporter”
mechanism for listing and exporting their module contents</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.all.inline_tests">
<span class="sig-prename descclassname"><span class="pre">clu.all.</span></span><span class="sig-name descname"><span class="pre">inline_tests</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">testername</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'test'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.all.inline_tests" title="Permalink to this definition"></a></dt>
<dd><p>Generator over all CLU modules that contain inline tests</p>
</dd></dl>

</section>
<section id="module-clu.api">
<span id="clu-api"></span><h1>clu.api<a class="headerlink" href="#module-clu.api" title="Permalink to this heading"></a></h1>
</section>
<section id="module-clu.application">
<span id="clu-application"></span><h1>clu.application<a class="headerlink" href="#module-clu.application" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.application.AppBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.application.</span></span><span class="sig-name descname"><span class="pre">AppBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.application.AppBase" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.application.Application">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.application.</span></span><span class="sig-name descname"><span class="pre">Application</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.application.Application" title="Permalink to this definition"></a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="clu.application.Application.finder">
<span class="sig-name descname"><span class="pre">finder</span></span><a class="headerlink" href="#clu.application.Application.finder" title="Permalink to this definition"></a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.application.Application.loader">
<span class="sig-name descname"><span class="pre">loader</span></span><a class="headerlink" href="#clu.application.Application.loader" title="Permalink to this definition"></a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">Loader</span></code></p>
</dd></dl>

</dd></dl>

</section>
<section id="module-clu.compilation">
<span id="clu-compliation"></span><h1>clu.compliation<a class="headerlink" href="#module-clu.compilation" title="Permalink to this heading"></a></h1>
</section>
<section id="module-clu.config.abc">
<span id="clu-config"></span><h1>clu.config<a class="headerlink" href="#module-clu.config.abc" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.config.abc.FlatOrderedSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.abc.</span></span><span class="sig-name descname"><span class="pre">FlatOrderedSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">*things</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predicate=&lt;function</span> <span class="pre">always&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.FlatOrderedSet" title="Permalink to this definition"></a></dt>
<dd><p>FlatOrderedSet is a structure designed to coalesce any nested
elements with which it is initialized into a flat, ordered sequence
devoid of None-values. It has both set and sequence properties –
membership can be tested as with a set; comparisons can be made with
less-than and greater-than operators, as with a set; recombinant 
operations are performed with binary-and and binary-or operators, as
with a set – but like a sequence, iterating a FlatOrderedSet has a
stable and deterministic order and items may be retrieved from an
instance using subscript indexes (e.g. flat_ordered_set[3]).</p>
<p>Here’s an example of the coalescing behavior:</p>
<blockquote>
<div><p>stuff = FlatOrderedSet(None, “a”, “b”, FlatOrderedSet(“c”, None, “a”, “d”))
summary = FlatOrderedSet(“a”, “b”, “c”, “d”)</p>
<p>assert stuff == summary</p>
</div></blockquote>
<p>One can optionally specify, as a keyword-only argument, a unary boolean
function “predicate” that will be used to filter out any of the items
used to initialize the FlatOrderedSet for which the predicate returns
a Falsey value.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.FlatOrderedSet.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.FlatOrderedSet.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a cloned copy of this instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.FlatOrderedSet.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.FlatOrderedSet.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.abc.FrozenKeyMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.abc.</span></span><span class="sig-name descname"><span class="pre">FrozenKeyMap</span></span><a class="headerlink" href="#clu.config.abc.FrozenKeyMap" title="Permalink to this definition"></a></dt>
<dd><p>The abstract base class for frozen – immutable once created – namespaced mappings,
also known as “FrozenKeyMaps”.</p>
<p>Subclasses must implement a bunch of typical Python dunder methods like e.g.
‘__iter__’, ‘__len__’ &amp;c, plus a “namespaces()” method which takes no arguments
and then iterates in order over all the THATS RIGHT YOU GUESSED IT namespaces
contained in the KeyMap’s keys.</p>
<p>Optionally one may override ‘__missing__’, which can be kind of interesting,
and ‘__bool__’ which generally is less so. Q.v. the “FrozenKeyMapBase” source
supra. for further deets, my doggie</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.FrozenKeyMap.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.FrozenKeyMap.get" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a (possibly namespaced) value for a given key.</p>
<p>An optional default value may be specified, to be returned
if the key in question is not found in the mapping.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.FrozenKeyMap.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.FrozenKeyMap.items" title="Permalink to this definition"></a></dt>
<dd><p>Return a namespaced view over either all key/value pairs in the
mapping, or over only those key/value pairs in the mapping whose
keys match the specified namespace values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.FrozenKeyMap.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.FrozenKeyMap.keys" title="Permalink to this definition"></a></dt>
<dd><p>Return a namespaced view over either all keys in the mapping,
or over only those keys in the mapping matching the specified
namespace values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.FrozenKeyMap.namespaces">
<span class="sig-name descname"><span class="pre">namespaces</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.FrozenKeyMap.namespaces" title="Permalink to this definition"></a></dt>
<dd><p>Iterate over all of the namespaces defined in the mapping.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.FrozenKeyMap.submap">
<span class="sig-name descname"><span class="pre">submap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.FrozenKeyMap.submap" title="Permalink to this definition"></a></dt>
<dd><p>Return a standard dict containing only the namespaced items.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.FrozenKeyMap.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.FrozenKeyMap.values" title="Permalink to this definition"></a></dt>
<dd><p>Return a namespaced view over either all values in the mapping,
or over only those values in the mapping whose keys match the
specified namespace values.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.abc.FrozenKeyMapBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.abc.</span></span><span class="sig-name descname"><span class="pre">FrozenKeyMapBase</span></span><a class="headerlink" href="#clu.config.abc.FrozenKeyMapBase" title="Permalink to this definition"></a></dt>
<dd><p>Abstract sub-base interface class for immutable namespaced mappings.
This is the root of the namespaced-mapping (née “KeyMap”) class tower.</p>
<p>Don’t subclass this, it’s just a bunch of abstract dunder methods and
other stuff to pass the buck properly from the ‘collections.abc’ bases
on up to our own API. You, for your purposes, should employ “FrozenKeyMap”
(without the “Base”) – q.v. the class definition below, sub.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.FrozenKeyMapBase.namespaces">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">namespaces</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.FrozenKeyMapBase.namespaces" title="Permalink to this definition"></a></dt>
<dd><p>Iterate over all of the namespaces defined in the mapping.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.abc.KeyMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.abc.</span></span><span class="sig-name descname"><span class="pre">KeyMap</span></span><a class="headerlink" href="#clu.config.abc.KeyMap" title="Permalink to this definition"></a></dt>
<dd><p>The abstract base class for mutable namespaced mappings (née “KeyMaps”).</p>
<p>Subclasses must implement all the requisite Python dunder methods required by
the ancestor “FrozenKeyMap”, like e.g. ‘__iter__’, ‘__len__’ &amp;c, plus also a
“namespaces()” method which takes no arguments and iterates in order over all
namespaces contained in the KeyMap’s keys.</p>
<p>OK AND FURTHERMORE for mutability, you also need to do your own ‘__setattr__’
and ‘__delattr__’ (which maybe we’ll make that last one optional as delete
methods in Python are totally gauche and a sign of a sort of naïve vulgar
un-Pythonicism, I feel like).</p>
<p>Optionally one may override ‘__missing__’, which can be kind of interesting,
and ‘__bool__’ which generally is less so. Q.v. the “FrozenKeyMapBase” source
supra. for further deets, my doggie</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.KeyMap.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.KeyMap.clear" title="Permalink to this definition"></a></dt>
<dd><p>Remove all items from the mapping – either in totality,
or only those matching a specific namespace.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.KeyMap.delete">
<span class="sig-name descname"><span class="pre">delete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.KeyMap.delete" title="Permalink to this definition"></a></dt>
<dd><p>Delete a (possibly namespaced) value from the mapping.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.KeyMap.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.KeyMap.pop" title="Permalink to this definition"></a></dt>
<dd><p>Pop a (possibly namespaced) value off the mapping
and eitehr return it or a default if it doesn’t
exist – raising a KeyError if no default is given.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.KeyMap.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.KeyMap.set" title="Permalink to this definition"></a></dt>
<dd><p>Set a (possibly namespaced) value for a given key.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.KeyMap.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">**F</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None.</span></span></span><a class="headerlink" href="#clu.config.abc.KeyMap.update" title="Permalink to this definition"></a></dt>
<dd><p>Update D from dict/iterable E and/or F.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.abc.KeyMapBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.abc.</span></span><span class="sig-name descname"><span class="pre">KeyMapBase</span></span><a class="headerlink" href="#clu.config.abc.KeyMapBase" title="Permalink to this definition"></a></dt>
<dd><p>Abstract sub-base interface class for mutable namespaced mappings.</p>
<p>Don’t subclass this anemic vestigial thing. You want “KeyMap” (sans
the “Base”) as your ancestor; see below.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.KeyMapBase.freeze">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">freeze</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.KeyMapBase.freeze" title="Permalink to this definition"></a></dt>
<dd><p>Return a “frozen” – or immutable – version of the KeyMap instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.abc.NamespaceWalker">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.abc.</span></span><span class="sig-name descname"><span class="pre">NamespaceWalker</span></span><a class="headerlink" href="#clu.config.abc.NamespaceWalker" title="Permalink to this definition"></a></dt>
<dd><p>A NamespaceWalker type implements a “walk(…)” method for iterating
over namespaced key-value items.</p>
<p>In return for furnishing this one method, NamespaceWalkers receive
implementations for “__iter__()”, “__len__()”, “__contains__(…)”,
and “__getitem__(…)”, plus optimized view-types returned from their
“keys(…)”, “items(…)” and “values(…)” calls, a “flatten(…)” method,
and an optimized version of the “namespaces()” method, ALL FREE!!</p>
<p>For KeyMap types whose backend mechanics are well-suited to being
“walked” (as it were) this is a remarkably good deal, would you not
agree??</p>
<p>See the docstring for “NamespaceWalker.walk(…)” for details. The
original “walk(…)” output format and model implementation were 
derived from this StackOverflow answer:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://stackoverflow.com/a/12507546/298171">https://stackoverflow.com/a/12507546/298171</a></p></li>
</ul>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.NamespaceWalker.flatten">
<span class="sig-name descname"><span class="pre">flatten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.NamespaceWalker.flatten" title="Permalink to this definition"></a></dt>
<dd><p>Dearticulate an articulated KeyMap instance into one that is flat.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.NamespaceWalker.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.NamespaceWalker.items" title="Permalink to this definition"></a></dt>
<dd><p>Return a namespaced view over either all key/value pairs in the
mapping, or over only those key/value pairs in the mapping whose
keys match the specified namespace values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.NamespaceWalker.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.NamespaceWalker.keys" title="Permalink to this definition"></a></dt>
<dd><p>Return a namespaced view over either all keys in the mapping,
or over only those keys in the mapping matching the specified
namespace values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.NamespaceWalker.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.NamespaceWalker.values" title="Permalink to this definition"></a></dt>
<dd><p>Return a namespaced view over either all values in the mapping,
or over only those values in the mapping whose keys match the
specified namespace values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.abc.NamespaceWalker.walk">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">walk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.NamespaceWalker.walk" title="Permalink to this definition"></a></dt>
<dd><p>The “walk(…)” method backs all other “NamespaceWalker” methods.</p>
<p>Concrete subclasses must implement “walk(…)” such that it iterates
over all items in a given instance, yielding them in a form like:</p>
<blockquote>
<div><dl class="simple">
<dt>for <a href="#id1"><span class="problematic" id="id2">*</span></a>namespaces, key, value in self.walk():</dt><dd><p># …</p>
</dd>
</dl>
</div></blockquote>
<p>… So an item with no namespaces would yield “[‘key’, ‘value’]”,
but one with three would yield “[‘do’, ‘re’, ‘me’, ‘key’, ‘value’]”.</p>
<p>See the “mapwalk(…)” and “envwalk(…)” function implementations,
for practical examples of how this can work. “mapwalk(…)” iterates
over nested dictionaries-of-dictionaries, and “envwalk(…)” transforms
the values in an environment dictionary (like ‘os.environ’) into the
above namespaced-key-value format, as noted.</p>
<p>N.B. Implementors may wish to write their own less-näive versions of
“__contains__(…)” and “__getitem__(…)” in their subclasses, depending
on how such subclasses work internally – in many cases, implementing
these methods using domain-specific logic will be faster and/or less
pathological than doing so using only “walk(…)”.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.abc.functional_and">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.abc.</span></span><span class="sig-name descname"><span class="pre">functional_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.functional_and" title="Permalink to this definition"></a></dt>
<dd><p>The “functional_and” FlatOrderedSet subclass is designed to hold
a sequence of functions. Instances of “functional_and” are callable –
calling “functional_and_instance(thing)” will apply each item held
by the instance to “thing”, returning True only if the instances’
functions all return a Truthy value.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.abc.functional_set">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.abc.</span></span><span class="sig-name descname"><span class="pre">functional_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.abc.functional_set" title="Permalink to this definition"></a></dt>
<dd><p>The “functional_set” FlatOrderedSet subclass is designed to hold
a sequence of functions. Instances of “functional_set” are callable –
calling “functional_set_instance(thing)” will successively apply
each function to either “thing” or the return value of the previous
function – finally returning the last return value when the sequence
of functions has been exhausted.</p>
</dd></dl>

<span class="target" id="module-clu.config.env"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.config.env.Environ">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.env.</span></span><span class="sig-name descname"><span class="pre">Environ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">environment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">updates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.Environ" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.config.env.Environ.freeze">
<span class="sig-name descname"><span class="pre">freeze</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.Environ.freeze" title="Permalink to this definition"></a></dt>
<dd><p>Return a “frozen” – or immutable – version of the KeyMap instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.env.Environ.setenv">
<span class="sig-name descname"><span class="pre">setenv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envkey</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.Environ.setenv" title="Permalink to this definition"></a></dt>
<dd><p>Set the value for a key directly in the backend environment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.env.Environ.unsetenv">
<span class="sig-name descname"><span class="pre">unsetenv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envkey</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.Environ.unsetenv" title="Permalink to this definition"></a></dt>
<dd><p>Delete a key directly from the backend environment</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.env.FrozenEnviron">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.env.</span></span><span class="sig-name descname"><span class="pre">FrozenEnviron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">environment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">updates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.FrozenEnviron" title="Permalink to this definition"></a></dt>
<dd><p>A concrete immutable – or frozen – KeyMap class wrapping a
frozen copy of an environment-variable dictionary.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.config.env.FrozenEnviron.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.FrozenEnviron.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a cloned copy of this instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.env.FrozenEnviron.envkeys">
<span class="sig-name descname"><span class="pre">envkeys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.FrozenEnviron.envkeys" title="Permalink to this definition"></a></dt>
<dd><p>Get a view on the dictionary keys from the backend environment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.env.FrozenEnviron.getenv">
<span class="sig-name descname"><span class="pre">getenv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envkey</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.FrozenEnviron.getenv" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a key directly from the backend environment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.env.FrozenEnviron.hasenv">
<span class="sig-name descname"><span class="pre">hasenv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envkey</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.FrozenEnviron.hasenv" title="Permalink to this definition"></a></dt>
<dd><p>Query the backend environment dictionary for a key.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.env.FrozenEnviron.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.FrozenEnviron.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return some readable meta-information about this instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.env.FrozenEnviron.walk">
<span class="sig-name descname"><span class="pre">walk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.FrozenEnviron.walk" title="Permalink to this definition"></a></dt>
<dd><p>Iteratively walk the backend environment access dictionary.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.env.envwalk">
<span class="sig-prename descclassname"><span class="pre">clu.config.env.</span></span><span class="sig-name descname"><span class="pre">envwalk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.env.envwalk" title="Permalink to this definition"></a></dt>
<dd><p>Iteratively walk an environment-variable mapping, selecting
only the variables prefixed for the given appname, and convert
environment-variable-packed namespaced key-value pairs into
the format expected for a “walk(…)” function.</p>
</dd></dl>

<span class="target" id="module-clu.config.keymap"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymap.Flat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymap.</span></span><span class="sig-name descname"><span class="pre">Flat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictionary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">updates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.Flat" title="Permalink to this definition"></a></dt>
<dd><p>A concrete mutable KeyMap class with a flat internal topology.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.config.keymap.Flat.freeze">
<span class="sig-name descname"><span class="pre">freeze</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.Flat.freeze" title="Permalink to this definition"></a></dt>
<dd><p>Return a “frozen” – or immutable – version of the KeyMap instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymap.FrozenFlat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymap.</span></span><span class="sig-name descname"><span class="pre">FrozenFlat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictionary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">updates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.FrozenFlat" title="Permalink to this definition"></a></dt>
<dd><p>A concrete immutable – or frozen – KeyMap class with a flat internal topology.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.config.keymap.FrozenFlat.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.FrozenFlat.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a cloned copy of this instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.keymap.FrozenFlat.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.FrozenFlat.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.keymap.FrozenFlat.nestify">
<span class="sig-name descname"><span class="pre">nestify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.FrozenFlat.nestify" title="Permalink to this definition"></a></dt>
<dd><p>Articulate a flattened KeyMap instance out into one that is nested.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymap.FrozenNested">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymap.</span></span><span class="sig-name descname"><span class="pre">FrozenNested</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">updates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.FrozenNested" title="Permalink to this definition"></a></dt>
<dd><p>A concrete immutable – or frozen – KeyMap class with an articulated –
or, if you will, a nested – internal topology.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.config.keymap.FrozenNested.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.FrozenNested.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a cloned copy of this instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.keymap.FrozenNested.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.FrozenNested.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.keymap.FrozenNested.submap">
<span class="sig-name descname"><span class="pre">submap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.FrozenNested.submap" title="Permalink to this definition"></a></dt>
<dd><p>Return a standard dict containing only the namespaced items.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.keymap.FrozenNested.walk">
<span class="sig-name descname"><span class="pre">walk</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.FrozenNested.walk" title="Permalink to this definition"></a></dt>
<dd><p>Iteratively walk the nested KeyMap’s tree of dicts.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymap.Nested">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymap.</span></span><span class="sig-name descname"><span class="pre">Nested</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">updates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.Nested" title="Permalink to this definition"></a></dt>
<dd><p>A concrete mutable KeyMap class with an articulated (or nested)
internal topology.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.config.keymap.Nested.freeze">
<span class="sig-name descname"><span class="pre">freeze</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.Nested.freeze" title="Permalink to this definition"></a></dt>
<dd><p>Return a “frozen” – or immutable – version of the KeyMap instance.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.keymap.mapwalk">
<span class="sig-prename descclassname"><span class="pre">clu.config.keymap.</span></span><span class="sig-name descname"><span class="pre">mapwalk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymap.mapwalk" title="Permalink to this definition"></a></dt>
<dd><p>Iteratively walk a nested mapping.
Based on <a class="reference external" href="https://stackoverflow.com/a/12507546/298171">https://stackoverflow.com/a/12507546/298171</a></p>
</dd></dl>

<span class="target" id="module-clu.config.keymapview"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymapview.KeyMapItemsView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymapview.</span></span><span class="sig-name descname"><span class="pre">KeyMapItemsView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymapview.KeyMapItemsView" title="Permalink to this definition"></a></dt>
<dd><p>A KeyMap items view.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymapview.KeyMapKeysView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymapview.</span></span><span class="sig-name descname"><span class="pre">KeyMapKeysView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymapview.KeyMapKeysView" title="Permalink to this definition"></a></dt>
<dd><p>A KeyMap key view.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymapview.KeyMapValuesView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymapview.</span></span><span class="sig-name descname"><span class="pre">KeyMapValuesView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymapview.KeyMapValuesView" title="Permalink to this definition"></a></dt>
<dd><p>A KeyMap values view.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymapview.KeyMapViewBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymapview.</span></span><span class="sig-name descname"><span class="pre">KeyMapViewBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymapview.KeyMapViewBase" title="Permalink to this definition"></a></dt>
<dd><p>The base class for KeyMap view classes.</p>
<p>These view classes correspond to, but do not inherit directly from,
the descendants of “collections.abc.MappingView”. They have been
specially kitted out to deal with KeyMap namespaces: each instance
has a ‘mapping’ attribute referring to the parent KeyMap instance,
a ‘namespaces’ iterable attribute with the unconcatenated namespace
parts for which the instance was allocated, and a ‘prefix’ shortcut
attribute containing the concatenated namespace parts as a string
prefix.</p>
<p>Each concrete subclass of KeyMapViewBase registers itself as a
“virtual subclass” of its corresponding ‘collections.abc’ view
class, like for good measure.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymapview.NamespaceWalkerItemsView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymapview.</span></span><span class="sig-name descname"><span class="pre">NamespaceWalkerItemsView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymapview.NamespaceWalkerItemsView" title="Permalink to this definition"></a></dt>
<dd><p>An items view specifically tailored to NamespaceWalker types.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymapview.NamespaceWalkerKeysView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymapview.</span></span><span class="sig-name descname"><span class="pre">NamespaceWalkerKeysView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymapview.NamespaceWalkerKeysView" title="Permalink to this definition"></a></dt>
<dd><p>A keys view specifically tailored to NamespaceWalker types.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymapview.NamespaceWalkerValuesView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymapview.</span></span><span class="sig-name descname"><span class="pre">NamespaceWalkerValuesView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymapview.NamespaceWalkerValuesView" title="Permalink to this definition"></a></dt>
<dd><p>A values view specifically tailored to NamespaceWalker types.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.keymapview.NamespaceWalkerViewBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.keymapview.</span></span><span class="sig-name descname"><span class="pre">NamespaceWalkerViewBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.keymapview.NamespaceWalkerViewBase" title="Permalink to this definition"></a></dt>
<dd><p>A view abstract base class tailored to NamespaceWalker types;
specifically, it overrides “__len__(…)” to better utilize
the underlying mapping types’ “walk(…)” method.</p>
</dd></dl>

<span class="target" id="module-clu.config.ns"></span><dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.compare_ns">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">compare_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterone</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itertwo</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.compare_ns" title="Permalink to this definition"></a></dt>
<dd><p>Boolean predicate to compare a pair of namespace iterables, value-by-value</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.concatenate_env">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">concatenate_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.concatenate_env" title="Permalink to this definition"></a></dt>
<dd><p>Concatenate and UPPERCASE namespaces, per environment variables.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.concatenate_ns">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">concatenate_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.concatenate_ns" title="Permalink to this definition"></a></dt>
<dd><p>Return the given namespace(s), concatenated with the
namespace separator.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.get_ns">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">get_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nskey</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.get_ns" title="Permalink to this definition"></a></dt>
<dd><p>Get the namespace portion of a namespaced key as a packed string.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.nskey_from_env">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">nskey_from_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envkey</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.nskey_from_env" title="Permalink to this definition"></a></dt>
<dd><p>Repack an environment-variable key name as a packed namespace key.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.nskey_to_env">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">nskey_to_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nskey</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.nskey_to_env" title="Permalink to this definition"></a></dt>
<dd><p>Repack a packed namespace key, with a given appname, as an environment
variable key name.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.pack_env">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">pack_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.pack_env" title="Permalink to this definition"></a></dt>
<dd><p>Transform a mapping key, along with optional “namespaces”
values and the provided “appname” value, into an environment-
variable name. Like e.g., for an appname of “YoDogg” and
a namespace value of “iheard”, the environment variable
prefix would work out such that a variable with a key value
of “youlike” would look like this:</p>
<blockquote>
<div><p>YODOGG_IHEARD_YOULIKE</p>
<dl>
<dt>^^^^^^ ^^^^^^ ^^^^^^^</dt><dd><div class="line-block">
<div class="line">|      |</div>
<div class="line">|      +––––– mapping key (uppercased)</div>
<div class="line">+–––––––––––– namespaces (uppercased, one value)</div>
</div>
<p>+––––––––––––––––––– app name (uppercased)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.pack_ns">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">pack_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.pack_ns" title="Permalink to this definition"></a></dt>
<dd><p>Pack a key and a set of (optional) namespaces into a namespaced key.</p>
<p>To wit: if called as “pack_ns(‘i-heard, ‘yo’, ‘dogg’)” the return
value will be the string “yo:dogg:i-heard”.</p>
<p>If no namespaces are provided (like e.g. “pack_ns(‘wat’)”)
the return value will be the string “wat”.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.prefix_env">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">prefix_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.prefix_env" title="Permalink to this definition"></a></dt>
<dd><p>Determine the environment-variable prefix based on a given
set of namespaces and the provided “appname” value. Like e.g.,
for an appname of “YoDogg” and a namespace value of “iheard”,
the environment variable prefix would work out such that
a variable with a key value of “youlike” would look like this:</p>
<blockquote>
<div><p>YODOGG_IHEARD_YOULIKE</p>
<dl>
<dt>^^^^^^ ^^^^^^ ^^^^^^^</dt><dd><div class="line-block">
<div class="line">|      |</div>
<div class="line">|      +––––– mapping key (uppercased)</div>
<div class="line">+–––––––––––– namespaces (uppercased, one value)</div>
</div>
<p>+––––––––––––––––––– app name (uppercased)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.prefix_for">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">prefix_for</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.prefix_for" title="Permalink to this definition"></a></dt>
<dd><p>Return the prefix string for the given namespace(s)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.split_ns">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">split_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">namespaced</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.split_ns" title="Permalink to this definition"></a></dt>
<dd><p>Split a namespaced string into its components</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.startswith_ns">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">startswith_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">putative</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.startswith_ns" title="Permalink to this definition"></a></dt>
<dd><p>Boolean predicate to compare a pair of namespace iterables,
returning True if the first starts with the second.</p>
<p>Do not confuse this with the helper function “compare_ns(…)”,
defined below, which returns False if the namespace iterables
in question aren’t exactly alike.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.strip_ns">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">strip_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nskey</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.strip_ns" title="Permalink to this definition"></a></dt>
<dd><p>Strip all namespace-related prefixing from a namespaced key</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.unpack_env">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">unpack_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envkey</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.unpack_env" title="Permalink to this definition"></a></dt>
<dd><p>Unpack the appname, possible namespaces, and the key from an environment
variable key name.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.unpack_ns">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">unpack_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nskey</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.unpack_ns" title="Permalink to this definition"></a></dt>
<dd><p>Unpack a namespaced key into a set of namespaces and a key name.</p>
<p>To wit: if the namespaced key is “yo:dogg:i-heard”, calling “unpack_ns(…)”
on it will return the tuple (‘i-heard’, (‘yo’, ‘dogg’));</p>
<p>If the key is not namespaced (like e.g. “wat”) the “unpack_ns(…)”
call will return the tuple (‘wat’, tuple()).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.ns.validate_ns">
<span class="sig-prename descclassname"><span class="pre">clu.config.ns.</span></span><span class="sig-name descname"><span class="pre">validate_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.ns.validate_ns" title="Permalink to this definition"></a></dt>
<dd><p>Raise a ValueError if any of the given namespaces are invalid.</p>
</dd></dl>

<span class="target" id="module-clu.config.proxy"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.config.proxy.KeyMapProxy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.proxy.</span></span><span class="sig-name descname"><span class="pre">KeyMapProxy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keymap</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.proxy.KeyMapProxy" title="Permalink to this definition"></a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="clu.config.proxy.KeyMapProxy.basetype">
<span class="sig-name descname"><span class="pre">basetype</span></span><a class="headerlink" href="#clu.config.proxy.KeyMapProxy.basetype" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#clu.config.abc.KeyMap" title="clu.config.abc.KeyMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyMap</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.proxy.KeyMapProxy.freeze">
<span class="sig-name descname"><span class="pre">freeze</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.proxy.KeyMapProxy.freeze" title="Permalink to this definition"></a></dt>
<dd><p>Return a “frozen” – or immutable – version of the KeyMap instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.config.proxy.KeyMapView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.config.proxy.</span></span><span class="sig-name descname"><span class="pre">KeyMapView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keymap</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.proxy.KeyMapView" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.config.proxy.KeyMapView.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.proxy.KeyMapView.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a cloned copy of this instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.proxy.KeyMapView.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.proxy.KeyMapView.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.proxy.KeyMapView.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.proxy.KeyMapView.items" title="Permalink to this definition"></a></dt>
<dd><p>Return a namespaced view over either all key/value pairs in the
mapping, or over only those key/value pairs in the mapping whose
keys match the specified namespace values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.proxy.KeyMapView.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.proxy.KeyMapView.keys" title="Permalink to this definition"></a></dt>
<dd><p>Return a namespaced view over either all keys in the mapping,
or over only those keys in the mapping matching the specified
namespace values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.proxy.KeyMapView.namespaces">
<span class="sig-name descname"><span class="pre">namespaces</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.proxy.KeyMapView.namespaces" title="Permalink to this definition"></a></dt>
<dd><p>Iterate over all of the namespaces defined in the mapping.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.config.proxy.KeyMapView.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">namespaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unprefixed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.proxy.KeyMapView.values" title="Permalink to this definition"></a></dt>
<dd><p>Return a namespaced view over either all values in the mapping,
or over only those values in the mapping whose keys match the
specified namespace values.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.config.proxy.selfcheck">
<span class="sig-prename descclassname"><span class="pre">clu.config.proxy.</span></span><span class="sig-name descname"><span class="pre">selfcheck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.config.proxy.selfcheck" title="Permalink to this definition"></a></dt>
<dd><p>Decorator abstracting a boolean self-check for weakref methods</p>
</dd></dl>

</section>
<section id="module-clu.csv">
<span id="clu-csv"></span><h1>clu.csv<a class="headerlink" href="#module-clu.csv" title="Permalink to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="clu.csv.max_segments">
<span class="sig-prename descclassname"><span class="pre">clu.csv.</span></span><span class="sig-name descname"><span class="pre">max_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">csv_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.csv.max_segments" title="Permalink to this definition"></a></dt>
<dd><p>max_segments(«uneven CSV data») → •largest line segment count•</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.csv.pad_csv">
<span class="sig-prename descclassname"><span class="pre">clu.csv.</span></span><span class="sig-name descname"><span class="pre">pad_csv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">csv_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.csv.pad_csv" title="Permalink to this definition"></a></dt>
<dd><p>pad_csv(«uneven CSV data») → «padded CSV data»</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.csv.pad_line">
<span class="sig-prename descclassname"><span class="pre">clu.csv.</span></span><span class="sig-name descname"><span class="pre">pad_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.csv.pad_line" title="Permalink to this definition"></a></dt>
<dd><p>pad_line(«uneven CSV lines») → «padded CSV lines»</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.csv.pad_segments">
<span class="sig-prename descclassname"><span class="pre">clu.csv.</span></span><span class="sig-name descname"><span class="pre">pad_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">csv_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.csv.pad_segments" title="Permalink to this definition"></a></dt>
<dd><p>pad_segments(«uneven CSV line fragments») → «padded CSV lines»</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.csv.segments">
<span class="sig-prename descclassname"><span class="pre">clu.csv.</span></span><span class="sig-name descname"><span class="pre">segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.csv.segments" title="Permalink to this definition"></a></dt>
<dd><p>segments(«CSV line») → •line segment count•</p>
</dd></dl>

</section>
<section id="module-clu.constants.consts">
<span id="clu-constants"></span><h1>clu.constants<a class="headerlink" href="#module-clu.constants.consts" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.constants.consts.NoDefault">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.consts.</span></span><span class="sig-name descname"><span class="pre">NoDefault</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.consts.NoDefault" title="Permalink to this definition"></a></dt>
<dd><p>A singleton object to signify a lack of an argument.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.constants.consts.pytuple">
<span class="sig-prename descclassname"><span class="pre">clu.constants.consts.</span></span><span class="sig-name descname"><span class="pre">pytuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">*attrs)</span> <span class="pre">→</span> <span class="pre">turns</span> <span class="pre">('do'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'re'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'mi')</span> <span class="pre">into</span> <span class="pre">('__do__'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'__re__'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'__mi__'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.consts.pytuple" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<span class="target" id="module-clu.constants.data"></span><span class="target" id="module-clu.constants.enums"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.constants.enums.CSIDL">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.enums.</span></span><span class="sig-name descname"><span class="pre">CSIDL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.enums.CSIDL" title="Permalink to this definition"></a></dt>
<dd><p>An enumeration encapsulating Windows CSIDLs.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.enums.CSIDL.for_name">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">for_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.enums.CSIDL.for_name" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a CSIDL by name (case-insensitively)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.constants.enums.CSIDL.fullname">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fullname</span></span><a class="headerlink" href="#clu.constants.enums.CSIDL.fullname" title="Permalink to this definition"></a></dt>
<dd><p>A CSIDL’s “full name” – which is basically of the form “CSIDL_NAME_STRING”</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.enums.CSIDL.to_int">
<span class="sig-name descname"><span class="pre">to_int</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.enums.CSIDL.to_int" title="Permalink to this definition"></a></dt>
<dd><p>A given CSIDL’s integer value</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.enums.CSIDL.to_string">
<span class="sig-name descname"><span class="pre">to_string</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.enums.CSIDL.to_string" title="Permalink to this definition"></a></dt>
<dd><p>A given CSIDL’s full name</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.constants.enums.System">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.enums.</span></span><span class="sig-name descname"><span class="pre">System</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.enums.System" title="Permalink to this definition"></a></dt>
<dd><p>An enumeration class for dealing with the name of the
underlying operating system upon which we are running.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.enums.System.all">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.enums.System.all" title="Permalink to this definition"></a></dt>
<dd><p>Get a generator over all System values</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.enums.System.determine">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">determine</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.enums.System.determine" title="Permalink to this definition"></a></dt>
<dd><p>Determine the System value for the current platform</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.enums.System.from_string">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.enums.System.from_string" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a System value by name (case-insensitively)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.constants.enums.System.is_current">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_current</span></span><a class="headerlink" href="#clu.constants.enums.System.is_current" title="Permalink to this definition"></a></dt>
<dd><p>A boolean value expressing if a given System value
represents the current running operating system</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.constants.enums.System.is_unix_based">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_unix_based</span></span><a class="headerlink" href="#clu.constants.enums.System.is_unix_based" title="Permalink to this definition"></a></dt>
<dd><p>A boolean value expressing if a given System value
represents a UNIX-based operating system</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.enums.System.match">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.enums.System.match" title="Permalink to this definition"></a></dt>
<dd><p>Match a system to a value – the nature of which can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>a string (unicode or bytes-type) naming the system;</p></li>
<li><p>an existing “System” enum-member value; or</p></li>
<li><p>an arbitrary alternative enum-member value.</p></li>
</ul>
</div></blockquote>
<p>… The matched system is returned. If no match is found,
a ValueError will be raised.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.constants.enums.System.os_name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">os_name</span></span><a class="headerlink" href="#clu.constants.enums.System.os_name" title="Permalink to this definition"></a></dt>
<dd><p>A given System value’s “os_name” (as reported when
running within a java-based environment e.g. Jython)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.constants.enums.System.sys_name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sys_name</span></span><a class="headerlink" href="#clu.constants.enums.System.sys_name" title="Permalink to this definition"></a></dt>
<dd><p>A given System value’s name, lowercased</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.enums.System.to_string">
<span class="sig-name descname"><span class="pre">to_string</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.enums.System.to_string" title="Permalink to this definition"></a></dt>
<dd><p>A given System value’s name</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.enums.System.unixes">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">unixes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.enums.System.unixes" title="Permalink to this definition"></a></dt>
<dd><p>Get a generator over the UNIX-based System values</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-clu.constants.exceptions"></span><dl class="py exception">
<dt class="sig sig-object py" id="clu.constants.exceptions.BadDotpathWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.exceptions.</span></span><span class="sig-name descname"><span class="pre">BadDotpathWarning</span></span><a class="headerlink" href="#clu.constants.exceptions.BadDotpathWarning" title="Permalink to this definition"></a></dt>
<dd><p>Conversion from a path to a dotpath resulted in a bad dotpath
… likely there are invalid characters like dashes in there.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="clu.constants.exceptions.CDBError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.exceptions.</span></span><span class="sig-name descname"><span class="pre">CDBError</span></span><a class="headerlink" href="#clu.constants.exceptions.CDBError" title="Permalink to this definition"></a></dt>
<dd><p>A problem with a compilation database</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="clu.constants.exceptions.ConfigurationError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.exceptions.</span></span><span class="sig-name descname"><span class="pre">ConfigurationError</span></span><a class="headerlink" href="#clu.constants.exceptions.ConfigurationError" title="Permalink to this definition"></a></dt>
<dd><p>An error that occurred in the course of macro configuration</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="clu.constants.exceptions.ExecutionError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.exceptions.</span></span><span class="sig-name descname"><span class="pre">ExecutionError</span></span><a class="headerlink" href="#clu.constants.exceptions.ExecutionError" title="Permalink to this definition"></a></dt>
<dd><p>An error during the execution of a shell command</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="clu.constants.exceptions.ExportError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.exceptions.</span></span><span class="sig-name descname"><span class="pre">ExportError</span></span><a class="headerlink" href="#clu.constants.exceptions.ExportError" title="Permalink to this definition"></a></dt>
<dd><p>An error during the preparation of an item for export</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="clu.constants.exceptions.ExportWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.exceptions.</span></span><span class="sig-name descname"><span class="pre">ExportWarning</span></span><a class="headerlink" href="#clu.constants.exceptions.ExportWarning" title="Permalink to this definition"></a></dt>
<dd><p>A non-life-threatening condition that occured during an export</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="clu.constants.exceptions.FilesystemError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.exceptions.</span></span><span class="sig-name descname"><span class="pre">FilesystemError</span></span><a class="headerlink" href="#clu.constants.exceptions.FilesystemError" title="Permalink to this definition"></a></dt>
<dd><p>An error that occurred while mucking about with the filesystem</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="clu.constants.exceptions.KeyValueError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.exceptions.</span></span><span class="sig-name descname"><span class="pre">KeyValueError</span></span><a class="headerlink" href="#clu.constants.exceptions.KeyValueError" title="Permalink to this definition"></a></dt>
<dd><p>An error raised in the clu.keyvalue API</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="clu.constants.exceptions.Nondeterminism">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.exceptions.</span></span><span class="sig-name descname"><span class="pre">Nondeterminism</span></span><a class="headerlink" href="#clu.constants.exceptions.Nondeterminism" title="Permalink to this definition"></a></dt>
<dd><p>An error indicating a “heisenbug” –
a nondeterministic problem.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="clu.constants.exceptions.UnusedValueWarning">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.exceptions.</span></span><span class="sig-name descname"><span class="pre">UnusedValueWarning</span></span><a class="headerlink" href="#clu.constants.exceptions.UnusedValueWarning" title="Permalink to this definition"></a></dt>
<dd><p>A warning issued when an AppDirs instance is initialized using
a value or values that aren’t currently utilized on the platform
upon which we are currently running</p>
</dd></dl>

<span class="target" id="module-clu.constants.polyfills"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.constants.polyfills.AutoType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.polyfills.</span></span><span class="sig-name descname"><span class="pre">AutoType</span></span><a class="headerlink" href="#clu.constants.polyfills.AutoType" title="Permalink to this definition"></a></dt>
<dd><p>Simple polyfill for <cite>enum.auto</cite> (which apparently
does not exist in PyPy 2 for some reason)</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.constants.polyfills.Enum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.polyfills.</span></span><span class="sig-name descname"><span class="pre">Enum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Enum" title="Permalink to this definition"></a></dt>
<dd><p>Generic enumeration.</p>
<p>Derive from this class to define new enumerations.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="clu.constants.polyfills.Enum.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#clu.constants.polyfills.Enum.name" title="Permalink to this definition"></a></dt>
<dd><p>The name of the Enum member.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.constants.polyfills.Enum.value">
<span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#clu.constants.polyfills.Enum.value" title="Permalink to this definition"></a></dt>
<dd><p>The value of the Enum member.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.constants.polyfills.EnumMeta">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.polyfills.</span></span><span class="sig-name descname"><span class="pre">EnumMeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classdict</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.EnumMeta" title="Permalink to this definition"></a></dt>
<dd><p>Metaclass for Enum</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.polyfills.</span></span><span class="sig-name descname"><span class="pre">Path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path" title="Permalink to this definition"></a></dt>
<dd><p>PurePath subclass that can make system calls.</p>
<p>Path represents a filesystem path but unlike PurePath, also offers
methods to do system calls on path objects. Depending on your system,
instantiating a Path will return either a PosixPath or a WindowsPath
object. You can also instantiate a PosixPath or WindowsPath directly,
but cannot instantiate a WindowsPath on a POSIX system or vice versa.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.absolute">
<span class="sig-name descname"><span class="pre">absolute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.absolute" title="Permalink to this definition"></a></dt>
<dd><p>Return an absolute version of this path.  This function works
even if the path doesn’t point to anything.</p>
<p>No normalization is done, i.e. all ‘.’ and ‘..’ will be kept along.
Use resolve() to get the canonical path to a file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.chmod">
<span class="sig-name descname"><span class="pre">chmod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.chmod" title="Permalink to this definition"></a></dt>
<dd><p>Change the permissions of the path, like os.chmod().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.cwd">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cwd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.cwd" title="Permalink to this definition"></a></dt>
<dd><p>Return a new path pointing to the current working directory
(as returned by os.getcwd()).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.exists">
<span class="sig-name descname"><span class="pre">exists</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.exists" title="Permalink to this definition"></a></dt>
<dd><p>Whether this path exists.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.expanduser">
<span class="sig-name descname"><span class="pre">expanduser</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.expanduser" title="Permalink to this definition"></a></dt>
<dd><p>Return a new path with expanded ~ and ~user constructs
(as returned by os.path.expanduser)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.glob">
<span class="sig-name descname"><span class="pre">glob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.glob" title="Permalink to this definition"></a></dt>
<dd><p>Iterate over this subtree and yield all existing files (of any
kind, including directories) matching the given relative pattern.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.group">
<span class="sig-name descname"><span class="pre">group</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.group" title="Permalink to this definition"></a></dt>
<dd><p>Return the group name of the file gid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.home">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">home</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.home" title="Permalink to this definition"></a></dt>
<dd><p>Return a new path pointing to the user’s home directory (as
returned by os.path.expanduser(‘~’)).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.is_block_device">
<span class="sig-name descname"><span class="pre">is_block_device</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.is_block_device" title="Permalink to this definition"></a></dt>
<dd><p>Whether this path is a block device.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.is_char_device">
<span class="sig-name descname"><span class="pre">is_char_device</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.is_char_device" title="Permalink to this definition"></a></dt>
<dd><p>Whether this path is a character device.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.is_dir">
<span class="sig-name descname"><span class="pre">is_dir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.is_dir" title="Permalink to this definition"></a></dt>
<dd><p>Whether this path is a directory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.is_fifo">
<span class="sig-name descname"><span class="pre">is_fifo</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.is_fifo" title="Permalink to this definition"></a></dt>
<dd><p>Whether this path is a FIFO.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.is_file">
<span class="sig-name descname"><span class="pre">is_file</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.is_file" title="Permalink to this definition"></a></dt>
<dd><p>Whether this path is a regular file (also True for symlinks pointing
to regular files).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.is_mount">
<span class="sig-name descname"><span class="pre">is_mount</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.is_mount" title="Permalink to this definition"></a></dt>
<dd><p>Check if this path is a POSIX mount point</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.is_socket">
<span class="sig-name descname"><span class="pre">is_socket</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.is_socket" title="Permalink to this definition"></a></dt>
<dd><p>Whether this path is a socket.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.is_symlink">
<span class="sig-name descname"><span class="pre">is_symlink</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.is_symlink" title="Permalink to this definition"></a></dt>
<dd><p>Whether this path is a symbolic link.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.iterdir">
<span class="sig-name descname"><span class="pre">iterdir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.iterdir" title="Permalink to this definition"></a></dt>
<dd><p>Iterate over the files in this directory.  Does not yield any
result for the special paths ‘.’ and ‘..’.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.lchmod">
<span class="sig-name descname"><span class="pre">lchmod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.lchmod" title="Permalink to this definition"></a></dt>
<dd><p>Like chmod(), except if the path points to a symlink, the symlink’s
permissions are changed, rather than its target’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.link_to">
<span class="sig-name descname"><span class="pre">link_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.link_to" title="Permalink to this definition"></a></dt>
<dd><p>Make the target path a hard link pointing to this path.</p>
<p>Note this function does not make this path a hard link to <em>target</em>,
despite the implication of the function and argument names. The order
of arguments (target, link) is the reverse of Path.symlink_to, but
matches that of os.link.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.lstat">
<span class="sig-name descname"><span class="pre">lstat</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.lstat" title="Permalink to this definition"></a></dt>
<dd><p>Like stat(), except if the path points to a symlink, the symlink’s
status information is returned, rather than its target’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.mkdir">
<span class="sig-name descname"><span class="pre">mkdir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">511</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exist_ok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.mkdir" title="Permalink to this definition"></a></dt>
<dd><p>Create a new directory at this given path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.open">
<span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffering</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.open" title="Permalink to this definition"></a></dt>
<dd><p>Open the file pointed by this path and return a file object, as
the built-in open() function does.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.owner">
<span class="sig-name descname"><span class="pre">owner</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.owner" title="Permalink to this definition"></a></dt>
<dd><p>Return the login name of the file owner.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.read_bytes">
<span class="sig-name descname"><span class="pre">read_bytes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.read_bytes" title="Permalink to this definition"></a></dt>
<dd><p>Open the file in bytes mode, read it, and close the file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.read_text">
<span class="sig-name descname"><span class="pre">read_text</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.read_text" title="Permalink to this definition"></a></dt>
<dd><p>Open the file in text mode, read it, and close the file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.readlink">
<span class="sig-name descname"><span class="pre">readlink</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.readlink" title="Permalink to this definition"></a></dt>
<dd><p>Return the path to which the symbolic link points.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.rename">
<span class="sig-name descname"><span class="pre">rename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.rename" title="Permalink to this definition"></a></dt>
<dd><p>Rename this path to the target path.</p>
<p>The target path may be absolute or relative. Relative paths are
interpreted relative to the current working directory, <em>not</em> the
directory of the Path object.</p>
<p>Returns the new Path instance pointing to the target path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.replace">
<span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.replace" title="Permalink to this definition"></a></dt>
<dd><p>Rename this path to the target path, overwriting if that path exists.</p>
<p>The target path may be absolute or relative. Relative paths are
interpreted relative to the current working directory, <em>not</em> the
directory of the Path object.</p>
<p>Returns the new Path instance pointing to the target path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.resolve">
<span class="sig-name descname"><span class="pre">resolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.resolve" title="Permalink to this definition"></a></dt>
<dd><p>Make the path absolute, resolving all symlinks on the way and also
normalizing it (for example turning slashes into backslashes under
Windows).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.rglob">
<span class="sig-name descname"><span class="pre">rglob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.rglob" title="Permalink to this definition"></a></dt>
<dd><p>Recursively yield all existing files (of any kind, including
directories) matching the given relative pattern, anywhere in
this subtree.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.rmdir">
<span class="sig-name descname"><span class="pre">rmdir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.rmdir" title="Permalink to this definition"></a></dt>
<dd><p>Remove this directory.  The directory must be empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.samefile">
<span class="sig-name descname"><span class="pre">samefile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.samefile" title="Permalink to this definition"></a></dt>
<dd><p>Return whether other_path is the same or not as this file
(as returned by os.path.samefile()).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.stat">
<span class="sig-name descname"><span class="pre">stat</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.stat" title="Permalink to this definition"></a></dt>
<dd><p>Return the result of the stat() system call on this path, like
os.stat() does.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.symlink_to">
<span class="sig-name descname"><span class="pre">symlink_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_is_directory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.symlink_to" title="Permalink to this definition"></a></dt>
<dd><p>Make this path a symlink pointing to the target path.
Note the order of arguments (link, target) is the reverse of os.symlink.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.touch">
<span class="sig-name descname"><span class="pre">touch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">438</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exist_ok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.touch" title="Permalink to this definition"></a></dt>
<dd><p>Create this file with the given access mode, if it doesn’t exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.unlink">
<span class="sig-name descname"><span class="pre">unlink</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">missing_ok</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.unlink" title="Permalink to this definition"></a></dt>
<dd><p>Remove this file or link.
If the path is a directory, use rmdir() instead.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.write_bytes">
<span class="sig-name descname"><span class="pre">write_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.write_bytes" title="Permalink to this definition"></a></dt>
<dd><p>Open the file in bytes mode, write to it, and close the file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.constants.polyfills.Path.write_text">
<span class="sig-name descname"><span class="pre">write_text</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.Path.write_text" title="Permalink to this definition"></a></dt>
<dd><p>Open the file in text mode, write to it, and close the file.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.constants.polyfills.auto">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.constants.polyfills.</span></span><span class="sig-name descname"><span class="pre">auto</span></span><a class="headerlink" href="#clu.constants.polyfills.auto" title="Permalink to this definition"></a></dt>
<dd><p>Instances are replaced with an appropriate value in Enum class suites.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.constants.polyfills.cache_from_source">
<span class="sig-prename descclassname"><span class="pre">clu.constants.polyfills.</span></span><span class="sig-name descname"><span class="pre">cache_from_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug_override</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.cache_from_source" title="Permalink to this definition"></a></dt>
<dd><p>Given the path to a .py file, return the path to its .pyc file.</p>
<p>The .py file does not need to exist; this simply returns the path to the
.pyc file calculated as if the .py file were imported.</p>
<p>The ‘optimization’ parameter controls the presumed optimization level of
the bytecode file. If ‘optimization’ is not None, the string representation
of the argument is taken and verified to be alphanumeric (else ValueError
is raised).</p>
<p>The debug_override parameter is deprecated. If debug_override is not None,
a True value is the same as setting ‘optimization’ to the empty string
while a False value is equivalent to setting ‘optimization’ to ‘1’.</p>
<p>If sys.implementation.cache_tag is None then NotImplementedError is raised.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.constants.polyfills.long">
<span class="sig-prename descclassname"><span class="pre">clu.constants.polyfills.</span></span><span class="sig-name descname"><span class="pre">long</span></span><a class="headerlink" href="#clu.constants.polyfills.long" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.constants.polyfills.lru_cache">
<span class="sig-prename descclassname"><span class="pre">clu.constants.polyfills.</span></span><span class="sig-name descname"><span class="pre">lru_cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">maxsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.lru_cache" title="Permalink to this definition"></a></dt>
<dd><p>Least-recently-used cache decorator.</p>
<p>If <em>maxsize</em> is set to None, the LRU features are disabled and the cache
can grow without bound.</p>
<p>If <em>typed</em> is True, arguments of different types will be cached separately.
For example, f(3.0) and f(3) will be treated as distinct calls with
distinct results.</p>
<p>Arguments to the cached function must be hashable.</p>
<p>View the cache statistics named tuple (hits, misses, maxsize, currsize)
with f.cache_info().  Clear the cache and statistics with f.cache_clear().
Access the underlying function with f.__wrapped__.</p>
<p>See:  <a class="reference external" href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU">https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU</a>)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.constants.polyfills.reduce">
<span class="sig-prename descclassname"><span class="pre">clu.constants.polyfills.</span></span><span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">value</span></span></span><a class="headerlink" href="#clu.constants.polyfills.reduce" title="Permalink to this definition"></a></dt>
<dd><p>Apply a function of two arguments cumulatively to the items of a sequence,
from left to right, so as to reduce the sequence to a single value.
For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
of the sequence in the calculation, and serves as a default when the
sequence is empty.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.constants.polyfills.unicode">
<span class="sig-prename descclassname"><span class="pre">clu.constants.polyfills.</span></span><span class="sig-name descname"><span class="pre">unicode</span></span><a class="headerlink" href="#clu.constants.polyfills.unicode" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.constants.polyfills.unique">
<span class="sig-prename descclassname"><span class="pre">clu.constants.polyfills.</span></span><span class="sig-name descname"><span class="pre">unique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enumeration</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.constants.polyfills.unique" title="Permalink to this definition"></a></dt>
<dd><p>Class decorator for enumerations ensuring unique member values.</p>
</dd></dl>

</section>
<section id="module-clu.dicts">
<span id="clu-dicts"></span><h1>clu.dicts<a class="headerlink" href="#module-clu.dicts" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.dicts.ChainMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">ChainMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">dicts</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">overrides</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.clear" title="Permalink to this definition"></a></dt>
<dd><p>Remove all items from the top mapping of the ChainMap.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a cloned copy of the ChainMap instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.flatten">
<span class="sig-name descname"><span class="pre">flatten</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.flatten" title="Permalink to this definition"></a></dt>
<dd><p>Dearticulate the ChainMap instances’ internal map stack
into a new, single, flat dictionary instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.fromitems">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fromitems</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">iterables</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">overrides</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.fromitems" title="Permalink to this definition"></a></dt>
<dd><p>Create a new ChainMap instance, using key-value pairs
obtained from one or more iterables, with any keyword
arguments serving as optional overrides.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.fromkeys">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fromkeys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">overrides</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.fromkeys" title="Permalink to this definition"></a></dt>
<dd><p>Create a new ChainMap instance, using keys plucked from
“iterable”, and values harvested from the subsequent
variadic arguments.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.get" title="Permalink to this definition"></a></dt>
<dd><p>Return the value for “key” if it is in any of the mappings
in the ChainMap, else “default”.</p>
<p>If no “default” is specified and the key is not found,
a KeyError will be raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.is_a">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_a</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.is_a" title="Permalink to this definition"></a></dt>
<dd><p>Check if an instance is a ChainMap of any sort – this covers:</p>
<ul class="simple">
<li><p>this class (whichever it may be, derived or otherwise)</p></li>
<li><p>the root clu.dicts.ChainMap type, and</p></li>
<li><p>the original collections.ChainMap type as well.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.mapchain">
<span class="sig-name descname"><span class="pre">mapchain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.mapchain" title="Permalink to this definition"></a></dt>
<dd><p>Return a generator over all of the ChainMap’s mappings</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.mapcontaining">
<span class="sig-name descname"><span class="pre">mapcontaining</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">itx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.mapcontaining" title="Permalink to this definition"></a></dt>
<dd><p>Search the ChainMap’s internal mappings for an item, by name,
and return the first mapping in which an item by this name
can be found.</p>
<p>A default value, returned when no mappings are to be found
containing an item by the specified name, may optionally
be passsed in as well.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.pop" title="Permalink to this definition"></a></dt>
<dd><p>chainmap.pop(key[, default]) → v, remove specified “key” from
the top mapping of the ChainMap, and return the corresponding
value.</p>
<p>If “key” is not found, “default” is returned if given –
otherwise a KeyError is raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.popitem">
<span class="sig-name descname"><span class="pre">popitem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">)</span> <span class="pre">→</span> <span class="pre">(key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove</span> <span class="pre">&amp;</span> <span class="pre">return</span> <span class="pre">a</span> <span class="pre">(key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.popitem" title="Permalink to this definition"></a></dt>
<dd><p>pair, nondeterministically, as a 2-tuple; but raise a KeyError
if the top mapping of the ChainMap (aka ‘self.maps[0]’) is empty.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.rest">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rest</span></span><a class="headerlink" href="#clu.dicts.ChainMap.rest" title="Permalink to this definition"></a></dt>
<dd><p>Return all of the mappings behind the first – aka <code class="docutils literal notranslate"><span class="pre">cdr(maps)</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.shift">
<span class="sig-name descname"><span class="pre">shift</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.shift" title="Permalink to this definition"></a></dt>
<dd><p>Create and return a new ChainMap instance from “maps[1:]” –
the “cdr(maps)”, for you Little Lispers out there –
as a shallow copy.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.top">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">top</span></span><a class="headerlink" href="#clu.dicts.ChainMap.top" title="Permalink to this definition"></a></dt>
<dd><p>Return the first mapping – aka <code class="docutils literal notranslate"><span class="pre">car(maps)</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainMap.unshift">
<span class="sig-name descname"><span class="pre">unshift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainMap.unshift" title="Permalink to this definition"></a></dt>
<dd><p>Create and return a new ChainMap with a new map followed
by all previous maps.</p>
<p>If no map is provided, an empty dict is used.</p>
<p>If the map provided is a ChainMap – either one from the
standard library “collections” module or from CLU, its
constituent maps will be torn from it and each gruesomely
vivisected into the new instance, as if the subject of a
scene deleted from a kind of Pythonic Saw movie.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.dicts.ChainRepr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">ChainRepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxlevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxstring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">120</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxother</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">120</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainRepr" title="Permalink to this definition"></a></dt>
<dd><p>Custom Repr-izer for “clu.dicts.ChainMap” composite
mappings, which can recursively self-contain, and not
infinitely recurse all over the living-room floor.</p>
<p>q.v. cpython docs, <a class="reference external" href="http://bit.ly/2r1GQ4l">http://bit.ly/2r1GQ4l</a> supra.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainRepr.primerepr">
<span class="sig-name descname"><span class="pre">primerepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainRepr.primerepr" title="Permalink to this definition"></a></dt>
<dd><p>The internal method for “core” repr production
of all ChainMaps, and related descendant types.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainRepr.shortrepr">
<span class="sig-name descname"><span class="pre">shortrepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainRepr.shortrepr" title="Permalink to this definition"></a></dt>
<dd><p>Return the “short” repr of a chainmap instance –
all whitespace will be condensed to single spaces
without newlines.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainRepr.subrepr">
<span class="sig-name descname"><span class="pre">subrepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainRepr.subrepr" title="Permalink to this definition"></a></dt>
<dd><p>An internal “core” repr helper method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.dicts.ChainRepr.toprepr">
<span class="sig-name descname"><span class="pre">toprepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chainmap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ChainRepr.toprepr" title="Permalink to this definition"></a></dt>
<dd><p>The “top-level” ChainMap-specific repr method –
this will parse through the individual mappings
that comprise the ChainMap instance, and dispatch
sub-repr method calls accordingly.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.dicts.OrderedItemsView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">OrderedItemsView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.OrderedItemsView" title="Permalink to this definition"></a></dt>
<dd><p>An items-view class implementing “collections.abc.Sequence”
and “collections.abc.Reversible”</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.dicts.OrderedKeysView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">OrderedKeysView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.OrderedKeysView" title="Permalink to this definition"></a></dt>
<dd><p>A keys-view class implementing “collections.abc.Sequence”
and “collections.abc.Reversible”</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.dicts.OrderedMappingView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">OrderedMappingView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.OrderedMappingView" title="Permalink to this definition"></a></dt>
<dd><p>A mapping view class implementing “collections.abc.Sequence”
and “collections.abc.Reversible”</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.dicts.OrderedValuesView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">OrderedValuesView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.OrderedValuesView" title="Permalink to this definition"></a></dt>
<dd><p>A values-view class implementing “collections.abc.Sequence”
and “collections.abc.Reversible”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dicts.asdict">
<span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">asdict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.asdict" title="Permalink to this definition"></a></dt>
<dd><p>asdict(thing) → returns either thing, thing.__dict__, or dict(thing) as necessary</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dicts.cmrepr">
<span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">cmrepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.cmrepr" title="Permalink to this definition"></a></dt>
<dd><p>Return the “core” repr for any descendant ChainMap type.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dicts.cmshortrepr">
<span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">cmshortrepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.cmshortrepr" title="Permalink to this definition"></a></dt>
<dd><p>Return the “short” repr of a chainmap instance –
all whitespace will be condensed to single spaces
without newlines.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dicts.ischainmap">
<span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">ischainmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.ischainmap" title="Permalink to this definition"></a></dt>
<dd><p>ischainmap(thing) → boolean predicate, True if the
type of “thing” is a ChainMap or a descendant of same –
either a “clu.dicts.ChainMap”, a “collections.ChainMap”;
anything will do… if this was the last time, then you should
tell us what to do.</p>
<p>I was afraid I guess, now I can’t think no more – I was so
concentrated on keeping things together; I’ve learned to
focus on. I didn’t want to disappoint. Now I miss everybody,
is it still light outside?</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dicts.merge">
<span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">merge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">dicts</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">overrides</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.merge" title="Permalink to this definition"></a></dt>
<dd><p>Merge all dictionary arguments into a new <cite>dict</cite> instance, using any
keyword arguments as item overrides in the final <cite>dict</cite> instance returned</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dicts.merge_as">
<span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">merge_as</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">*dicts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls=&lt;class</span> <span class="pre">'dict'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**overrides</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.merge_as" title="Permalink to this definition"></a></dt>
<dd><p>Merge all dictionary arguments into a new instance of the specified class,
passing all additional keyword arguments to the class constructor as overrides</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dicts.merge_fast">
<span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">merge_fast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">dicts</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">extras</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.merge_fast" title="Permalink to this definition"></a></dt>
<dd><p>Merge all dictionary arguments into a new instance of “dict”.
passing all additional keyword arguments as an additional dict instance.</p>
<dl class="simple">
<dt>Based on this extremely beloved SO answer:</dt><dd><p><a class="reference external" href="https://stackoverflow.com/a/26853961/298171">https://stackoverflow.com/a/26853961/298171</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dicts.merge_fast_two">
<span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">merge_fast_two</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.merge_fast_two" title="Permalink to this definition"></a></dt>
<dd><p>Merge two dictionaries performantly into an instance of “dict”.</p>
<dl class="simple">
<dt>Based on this extremely beloved SO answer:</dt><dd><p><a class="reference external" href="https://stackoverflow.com/a/26853961/298171">https://stackoverflow.com/a/26853961/298171</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dicts.merge_two">
<span class="sig-prename descclassname"><span class="pre">clu.dicts.</span></span><span class="sig-name descname"><span class="pre">merge_two</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls=&lt;class</span> <span class="pre">'dict'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dicts.merge_two" title="Permalink to this definition"></a></dt>
<dd><p>Merge two dictionaries into an instance of the specified class.</p>
<p>Based on this docopt example source: <a class="reference external" href="https://git.io/fjCZ6">https://git.io/fjCZ6</a></p>
</dd></dl>

</section>
<section id="module-clu.dispatch">
<span id="clu-dispatch"></span><h1>clu.dispatch<a class="headerlink" href="#module-clu.dispatch" title="Permalink to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="clu.dispatch.exithandle">
<span class="sig-prename descclassname"><span class="pre">clu.dispatch.</span></span><span class="sig-name descname"><span class="pre">exithandle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dispatch.exithandle" title="Permalink to this definition"></a></dt>
<dd><p>Register a function with “atexit” and various program-exit signals</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dispatch.nhandles">
<span class="sig-prename descclassname"><span class="pre">clu.dispatch.</span></span><span class="sig-name descname"><span class="pre">nhandles</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.dispatch.nhandles" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of registered exit-handle functions</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dispatch.shutdown">
<span class="sig-prename descclassname"><span class="pre">clu.dispatch.</span></span><span class="sig-name descname"><span class="pre">shutdown</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">send</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Signals.SIGSTOP</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dispatch.shutdown" title="Permalink to this definition"></a></dt>
<dd><p>Run all exit handles, and commence an orderly shutdown</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dispatch.signal_for">
<span class="sig-prename descclassname"><span class="pre">clu.dispatch.</span></span><span class="sig-name descname"><span class="pre">signal_for</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signum</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dispatch.signal_for" title="Permalink to this definition"></a></dt>
<dd><p>Return the signal enum value for a given signal number</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dispatch.trigger">
<span class="sig-prename descclassname"><span class="pre">clu.dispatch.</span></span><span class="sig-name descname"><span class="pre">trigger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">send</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Signals.SIGSTOP</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dispatch.trigger" title="Permalink to this definition"></a></dt>
<dd><p>Run and unregister all exit handle functions without exiting</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dispatch.unregister">
<span class="sig-prename descclassname"><span class="pre">clu.dispatch.</span></span><span class="sig-name descname"><span class="pre">unregister</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.dispatch.unregister" title="Permalink to this definition"></a></dt>
<dd><p>Unregister a previously-registered exit handle function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.dispatch.unregister_all">
<span class="sig-prename descclassname"><span class="pre">clu.dispatch.</span></span><span class="sig-name descname"><span class="pre">unregister_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.dispatch.unregister_all" title="Permalink to this definition"></a></dt>
<dd><p>Unregister <em>all</em> previously-registered exit handle functions</p>
</dd></dl>

</section>
<section id="module-clu.enums">
<span id="clu-enums"></span><h1>clu.enums<a class="headerlink" href="#module-clu.enums" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.enums.AliasingEnum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.enums.</span></span><span class="sig-name descname"><span class="pre">AliasingEnum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.enums.AliasingEnum" title="Permalink to this definition"></a></dt>
<dd><p>An Enum subclass intermediate, suitable for subclassing
itself, that uses <cite>AliasingEnumMeta</cite> as its metaclass.</p>
<p>…Thus, any member aliases that one makes in concrete
classes derived from this class will find them registered
upon class creation in an <cite>__aliases__</cite> directory on the
derived class.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.enums.AliasingEnumMeta">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.enums.</span></span><span class="sig-name descname"><span class="pre">AliasingEnumMeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.enums.AliasingEnumMeta" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-clu.exporting">
<span id="clu-exporting"></span><h1>clu.exporting<a class="headerlink" href="#module-clu.exporting" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.exporting.Exporter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">Exporter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dotpath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.Exporter" title="Permalink to this definition"></a></dt>
<dd><p>A class representing a list of things for a module to export.</p>
<p>This class is specifically germane to the CLU project – note
that the “basepath” class keyword is used to assign a value from
the CLU constants module.</p>
<p>Users of CLU who wish to use the Exporter mechanism in their
own projects should create a subclass of ExporterBase of their
own. Like this one, it need only assign the “basepath” class
keyword; it is unnecessary (but OK!) to define further methods,
properties, class constants, and whatnot.</p>
<p>When writing your subclass, if you •do• choose to add methods
or other things, it is imperative that you ensure you aren’t
accedentally clobbering anything important from ExporterBase,
or you risk UNDEFINED BEHAVIOR!!!! Erm.</p>
<p>Also note that all derived subclasses of ExporterBase will
automatically be slotted classes – a “__slots__” attribute
will be added to the class dict by the “clu.abstract.Slotted”
metaclass, if your subclass doesn’t define one – and so if
you desire a class with a working “__dict__” attribute for
some reason, you’ll need to specify:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="vm">__slots__</span> <span class="o">=</span> <span class="n">tuplize</span><span class="p">(</span><span class="s1">&#39;__dict__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>… in your class (or an equivalent).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">ExporterBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dotpath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase" title="Permalink to this definition"></a></dt>
<dd><p>The base class for “clu.exporting.Exporter”. Override this
class in your own project to use the CLU exporting mechanism –
q.v. “clu.exporting.Exporter” docstring sub.</p>
<p>This class uses the “clu.abstract.BasePath” metaclass, which
automatically adds a “basepath” class attribute, as well as
the “clu.exporting.Registry” mixin, which keeps a registry
containing it and all of its derived subclasses, and furnishes
the “instances” weak-value dictionary for instance registration.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.all_and_dir">
<span class="sig-name descname"><span class="pre">all_and_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">additionals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.all_and_dir" title="Permalink to this definition"></a></dt>
<dd><p>Assign a modules’ __all__ and __dir__ values, e.g.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">__all__</span><span class="p">,</span> <span class="fm">__dir__</span> <span class="o">=</span> <span class="n">exporter</span><span class="o">.</span><span class="n">all_and_dir</span><span class="p">()</span>
</pre></div>
</div>
<p>… This should be done near the end of a module, after
all calls to <cite>exporter.export(…)</cite> (aka &#64;export) have
been made – q.v. the “decorator()” method supra.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.all_tuple">
<span class="sig-name descname"><span class="pre">all_tuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">additionals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.all_tuple" title="Permalink to this definition"></a></dt>
<dd><p>For use in module <cite>__all__</cite> tuple definitions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.cache_info">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cache_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.cache_info" title="Permalink to this definition"></a></dt>
<dd><p>Shortcut to get the CacheInfo namedtuple from the
cached internal <cite>search_by_id(…)</cite> function,
which is used in last-resort name lookups made by
<cite>determine_name(…)</cite> during <cite>export(…)</cite> calls.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.decorator">
<span class="sig-name descname"><span class="pre">decorator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.decorator" title="Permalink to this definition"></a></dt>
<dd><p>Return a reference to this Exporter instances’ “export”
method, suitable for use as a decorator, e.g.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">export</span> <span class="o">=</span> <span class="n">exporter</span><span class="o">.</span><span class="n">decorator</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; @export
&gt;&gt;&gt; def yodogg():
&gt;&gt;&gt;     &#39;&#39;&#39; Yo dogg, I heard you like exporting &#39;&#39;&#39;
&gt;&gt;&gt;     …
</pre></div>
</div>
<p>… This should be done near the beginning of a module,
to facilitate marking functions and other objects to be
exported – q.v. the “all_and_dir()” method sub.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.dir_and_all">
<span class="sig-name descname"><span class="pre">dir_and_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">additionals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.dir_and_all" title="Permalink to this definition"></a></dt>
<dd><p>Assign a modules’ __dir__ and __all__ values, e.g.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="fm">__dir__</span><span class="p">,</span> <span class="n">__all__</span> <span class="o">=</span> <span class="n">exporter</span><span class="o">.</span><span class="n">dir_and_all</span><span class="p">()</span>
</pre></div>
</div>
<p>… This should be done near the end of a module, after
all calls to <cite>exporter.export(…)</cite> (aka &#64;export) have
been made – q.v. the “decorator()” method supra.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.dir_function">
<span class="sig-name descname"><span class="pre">dir_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">additionals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.dir_function" title="Permalink to this definition"></a></dt>
<dd><p>Return a list containing the exported module names.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.export">
<span class="sig-name descname"><span class="pre">export</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.export" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Add a function – or any object, really – to the export list.</dt><dd><p>Exported items will end up wih their names in the modules’</p>
</dd>
<dt><cite>__all__</cite> tuple, and will also be named in the list returned</dt><dd><p>by the modules’ <cite>__dir__()</cite> function.</p>
<p>It looks better if this method is decoupled from its parent
instance, to wit:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exporter</span> <span class="o">=</span> <span class="n">Exporter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">export</span> <span class="o">=</span> <span class="n">exporter</span><span class="o">.</span><span class="n">decorator</span><span class="p">()</span> <span class="c1"># q.v. “decorator()” sub.</span>
</pre></div>
</div>
<p>Use <cite>export</cite> as a decorator to a function definition:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; @export
&gt;&gt;&gt; def yo_dogg(i_heard=None):
&gt;&gt;&gt;     …
</pre></div>
</div>
<p>… or manually, to export anything that doesn’t have a name:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; yo_dogg = lambda i_heard=None: …
&gt;&gt;&gt; dogg_heard_index = ( ¬ ) 
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">export</span><span class="p">(</span><span class="n">yo_dogg</span><span class="p">,</span>             <span class="n">name</span><span class="o">=</span><span class="s2">&quot;yo_dogg&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">export</span><span class="p">(</span><span class="n">dogg_heard_index</span><span class="p">,</span>    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dogg_heard_index&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.exports">
<span class="sig-name descname"><span class="pre">exports</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.exports" title="Permalink to this definition"></a></dt>
<dd><p>Get a new dictionary instance filled with the exports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.get" title="Permalink to this definition"></a></dt>
<dd><p>Get and return a value for a key, with an optional default</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Stringify a subset of the Exporter instances’ fields.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.items" title="Permalink to this definition"></a></dt>
<dd><p>Get a item view on the exported items dictionary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.keys" title="Permalink to this definition"></a></dt>
<dd><p>Get a key view on the exported items dictionary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.module">
<span class="sig-name descname"><span class="pre">module</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.module" title="Permalink to this definition"></a></dt>
<dd><p>Shortcut to get the parent module for the exporter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.modulenames">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">modulenames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.modulenames" title="Permalink to this definition"></a></dt>
<dd><p>Get a generator yielding from a sorted list of module names
– keys to the Exporter instance registry – currently available</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.moduleof">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">moduleof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.moduleof" title="Permalink to this definition"></a></dt>
<dd><p>Find and return the module for a thing, if that thing
should be found to reside in one of the exported modules</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.modules">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">modules</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.modules" title="Permalink to this definition"></a></dt>
<dd><p>Get a dictionary of actual modules corresponding to the
currently registered Exporter instances</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.nameof">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nameof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.nameof" title="Permalink to this definition"></a></dt>
<dd><p>Find and return the name of a thing, if that thing
should be found to reside in one of the exported modules</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.pop" title="Permalink to this definition"></a></dt>
<dd><p>Remove and return a value for a key, with an optional default</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.unregister">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">unregister</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dotpath</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.unregister" title="Permalink to this definition"></a></dt>
<dd><p>Unregister a previously-registered ExporterBase instance,
specified by the dotted path (née “dotpath”) of the module
in which it is ensconced.</p>
<p>Returns the successfully unregistered instance in question.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictish=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**updates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the exporter with key/value pairs and/or an iterator;
q.v. <cite>dict.update(…)</cite> docstring supra.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.ExporterBase.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterBase.values" title="Permalink to this definition"></a></dt>
<dd><p>Get a value view on the exported items dictionary.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.exporting.ExporterTypeRepr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">ExporterTypeRepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basepath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.ExporterTypeRepr" title="Permalink to this definition"></a></dt>
<dd><p>At the time of writing, type-specific “__repr__(…)” definitions
require the use of a metaclass – soooooooo…</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.exporting.Modulespace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">Modulespace</span></span><a class="headerlink" href="#clu.exporting.Modulespace" title="Permalink to this definition"></a></dt>
<dd><p>Makes top-level python modules available as an attribute,
importing them on first access.</p>
<dl class="simple">
<dt>Q.v. pypy/rpython source supra:</dt><dd><p><a class="reference external" href="http://bit.ly/lazy-borg-modulespace">http://bit.ly/lazy-borg-modulespace</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.exporting.Registry">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">Registry</span></span><a class="headerlink" href="#clu.exporting.Registry" title="Permalink to this definition"></a></dt>
<dd><p>A class-registry mixin ancestor type suitable for use
in the ExporterBase inheritance chain – it uses the
“clu.abstract.Slotted” metaclass and respects the
class keywords already in use.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.Registry.all_appnames">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_appnames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.Registry.all_appnames" title="Permalink to this definition"></a></dt>
<dd><p>Return a generator over all currently registered appnames</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.Registry.exports">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">exports</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.Registry.exports" title="Permalink to this definition"></a></dt>
<dd><p>An abstract method, ensuring Registry types can’t be just
instantiated willy-nilly. The clu.exporting.ExporterBase
descendant class implements this method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.Registry.for_appname">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">for_appname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.Registry.for_appname" title="Permalink to this definition"></a></dt>
<dd><p>Return a subclass for a registered appname</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.Registry.has_appname">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">has_appname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.Registry.has_appname" title="Permalink to this definition"></a></dt>
<dd><p>Check to see if a given appname has a registered subclass</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.Registry.moduleof">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">moduleof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.Registry.moduleof" title="Permalink to this definition"></a></dt>
<dd><p>Find and return the module for a thing, if that thing
should be found to reside in one of the exported modules</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.Registry.nameof">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nameof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.Registry.nameof" title="Permalink to this definition"></a></dt>
<dd><p>Find and return the name of a thing, if that thing
should be found to reside in one of the exported modules</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.exporting.Registry.unregister">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">unregister</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.Registry.unregister" title="Permalink to this definition"></a></dt>
<dd><p>Unregister a previously-registered appname, returning the
successfully unregistered ExporterBase subclass.</p>
<p>Attempting to unregister the core CLU application’s exporter
is not allowed and will raise a KeyError.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.exporting.determine_name">
<span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">determine_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">try_repr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.determine_name" title="Permalink to this definition"></a></dt>
<dd><p>Private module function to find a name for a thing.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.exporting.itermodule">
<span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">itermodule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.itermodule" title="Permalink to this definition"></a></dt>
<dd><p>Get an iterable of <cite>(name, thing)</cite> tuples for all things
contained in a given module (although it’ll probably work
for classes and instances too – anything <cite>dir()</cite>-able.)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.exporting.itermoduleids">
<span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">itermoduleids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.itermoduleids" title="Permalink to this definition"></a></dt>
<dd><p>Internal function to get an iterable of <cite>(name, id(thing))</cite>
tuples for all things comntained in a given module – q.v.
<cite>itermodule(…)</cite> implementation supra.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.exporting.moduleids">
<span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">moduleids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.moduleids" title="Permalink to this definition"></a></dt>
<dd><p>Get a dictionary of <cite>(name, thing)</cite> tuples from a module,
indexed by the <cite>id()</cite> value of <cite>thing</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.exporting.path_to_dotpath">
<span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">path_to_dotpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.path_to_dotpath" title="Permalink to this definition"></a></dt>
<dd><p>Convert a file path (e.g. “/yo/dogg/iheard/youlike.py”)
to a dotpath (á la “yo.dogg.iheard.youlike”) in what I
would call a “quick and dirty” fashion.</p>
<p>Issues a BadDotpathWarning if the converted path contains
dashes – I don’t quite know what to do about something
like that besides warn, so erm. There you go.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.exporting.search_by_id">
<span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">search_by_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thingID</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.search_by_id" title="Permalink to this definition"></a></dt>
<dd><p>Cached function to find the name of a thing, according
to what it is called in the context of a module in which
it resides – searching across all currently imported
modules in entirely, as indicated from the inspection of
<cite>sys.modules.values()</cite> (which is potentially completely
fucking enormous).</p>
<p>This function implements <cite>search_for_name(…)</cite> – q.v.
the calling function code sub., and is also used in the
implementation of <cite>determine_module(…)</cite>, - also q.v.
the calling function code sub.</p>
<p>Caching courtesy the <cite>functools.lru_cache(…)</cite> decorator.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.exporting.search_for_module">
<span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">search_for_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.search_for_module" title="Permalink to this definition"></a></dt>
<dd><p>Attempt to find the module containing “thing”, using the
logic from the <cite>search_modules(…)</cite> function, applied to
all currently imported modules, as indicated from the
inspection of <cite>sys.modules.values()</cite> (which that, as a
search space, is potentially fucking enormous).</p>
<p>This function may be called by <cite>determine_name(…)</cite>. Its
subordinate internal function, <cite>search_by_id(…)</cite>,
uses the LRU cache from <cite>functools</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.exporting.search_for_name">
<span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">search_for_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.search_for_name" title="Permalink to this definition"></a></dt>
<dd><p>Attempt to find the name for “thing”, using the logic from
the <cite>search_modules(…)</cite> function, applied to all currently
imported modules, as indicated from the inspection of
<cite>sys.modules.values()</cite> (which that, as a search space,
is potentially fucking enormous).</p>
<p>This function may be called by <cite>determine_name(…)</cite>. Its
subordinate internal function, <cite>search_by_id(…)</cite>,
uses the LRU cache from <cite>functools</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.exporting.search_modules">
<span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">search_modules</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">modules</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.search_modules" title="Permalink to this definition"></a></dt>
<dd><p>Find the name of a thing, according to what it is called
in the context of a module in which it resides</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.exporting.thismodule">
<span class="sig-prename descclassname"><span class="pre">clu.exporting.</span></span><span class="sig-name descname"><span class="pre">thismodule</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.exporting.thismodule" title="Permalink to this definition"></a></dt>
<dd><p>thismodule() → return the name of the module in which the <cite>thismodule()</cite> function was called</p>
</dd></dl>

</section>
<section id="module-clu.extending">
<span id="clu-extending"></span><h1>clu.extending<a class="headerlink" href="#module-clu.extending" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.extending.DoubleDutchRegistry">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.extending.</span></span><span class="sig-name descname"><span class="pre">DoubleDutchRegistry</span></span><a class="headerlink" href="#clu.extending.DoubleDutchRegistry" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.extending.DoubleDutchRegistry.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.extending.DoubleDutchRegistry.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.extending.Extensible">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.extending.</span></span><span class="sig-name descname"><span class="pre">Extensible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.extending.Extensible" title="Permalink to this definition"></a></dt>
<dd><p>Two magic tricks for classes:</p>
<blockquote>
<div><p># In one file…
class X(metaclass=Extensible):</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p># In some other file…
class __extend__(X):</p>
<blockquote>
<div><dl class="simple">
<dt>…      # and here you can add new methods</dt><dd><p># and class attributes to X!</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>Mostly useful together with the second trick, which lets you build
methods whose “self” is a pair of objects, instead of just one:</p>
<blockquote>
<div><dl>
<dt>class __extend__(pairtype(X, Y)):</dt><dd><p>attribute = 42
def method(pair_xy, other, arguments):</p>
<blockquote>
<div><p>x, y = pair_xy
…</p>
</div></blockquote>
</dd>
</dl>
<p>pair(x, y).attribute
pair(x, y).method(other, arguments)</p>
</div></blockquote>
<p>This finds methods and class attributes based on the actual
class of both objects that go into the “pair()”, with the usual
rules of method/attribute overriding in (pairs of) subclasses.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.extending.doubledutch">
<span class="sig-prename descclassname"><span class="pre">clu.extending.</span></span><span class="sig-name descname"><span class="pre">doubledutch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.extending.doubledutch" title="Permalink to this definition"></a></dt>
<dd><p>Decorator returning a double-dispatch function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@doubledutch</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@func</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s2">&quot;42&quot;</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@func</span><span class="o">.</span><span class="n">annotated</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="go">&quot;42&quot;</span>
<span class="go">--------------------------------</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.extending.pair">
<span class="sig-prename descclassname"><span class="pre">clu.extending.</span></span><span class="sig-name descname"><span class="pre">pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.extending.pair" title="Permalink to this definition"></a></dt>
<dd><p>Return a pair object – a descendant of “__builtin__.tuple”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.extending.pairmro">
<span class="sig-prename descclassname"><span class="pre">clu.extending.</span></span><span class="sig-name descname"><span class="pre">pairmro</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.extending.pairmro" title="Permalink to this definition"></a></dt>
<dd><p>Return the resolution order on pairs of types for double dispatch.</p>
<p>This order is compatible with the mro of <cite>pairtype(cls0, cls1)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.extending.pairtype">
<span class="sig-prename descclassname"><span class="pre">clu.extending.</span></span><span class="sig-name descname"><span class="pre">pairtype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.extending.pairtype" title="Permalink to this definition"></a></dt>
<dd><p><cite>type(pair(a, b))</cite> is “pairtype(typeof(a), typeof(b))”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.extending.">
<span class="sig-prename descclassname"><span class="pre">clu.extending.</span></span><span class="sig-name descname"><span class="pre">Ω</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">one</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">two</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.extending." title="Permalink to this definition"></a></dt>
<dd><p>Return a pair object – a descendant of “__builtin__.tuple”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">clu.extending.</span></span><span class="sig-name descname"><span class="pre">ΩΩ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Permalink to this definition"></a></dt>
<dd><p><cite>type(pair(a, b))</cite> is “pairtype(typeof(a), typeof(b))”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id3">
<span class="sig-prename descclassname"><span class="pre">clu.extending.</span></span><span class="sig-name descname"><span class="pre">ω</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id3" title="Permalink to this definition"></a></dt>
<dd><p>Return the resolution order on pairs of types for double dispatch.</p>
<p>This order is compatible with the mro of <cite>pairtype(cls0, cls1)</cite></p>
</dd></dl>

</section>
<section id="module-clu.fs.abc">
<span id="clu-fs"></span><h1>clu.fs<a class="headerlink" href="#module-clu.fs.abc" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.abc.</span></span><span class="sig-name descname"><span class="pre">BaseFSName</span></span><a class="headerlink" href="#clu.fs.abc.BaseFSName" title="Permalink to this definition"></a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.basename">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">basename</span></span><a class="headerlink" href="#clu.fs.abc.BaseFSName.basename" title="Permalink to this definition"></a></dt>
<dd><p>The basename (aka the name of the instance, like as opposed to the
entire fucking absolute path) of the target instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.abc.BaseFSName.close" title="Permalink to this definition"></a></dt>
<dd><p>Stub method – always returns True:</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.dirname">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dirname</span></span><a class="headerlink" href="#clu.fs.abc.BaseFSName.dirname" title="Permalink to this definition"></a></dt>
<dd><p>The dirname (aka the path of the enclosing directory) of the target
instance, wrapped in a new Directory instance.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.exists">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">exists</span></span><a class="headerlink" href="#clu.fs.abc.BaseFSName.exists" title="Permalink to this definition"></a></dt>
<dd><p>Whether or not the instances’ target path exists as a directory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.abc.BaseFSName.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.name">
<em class="property"><span class="pre">abstract</span><span class="w"> </span><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#clu.fs.abc.BaseFSName.name" title="Permalink to this definition"></a></dt>
<dd><p>The instances’ target path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.parent">
<span class="sig-name descname"><span class="pre">parent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.abc.BaseFSName.parent" title="Permalink to this definition"></a></dt>
<dd><p>Sugar for <cite>self.directory(os.path.abspath(os.path.dirname(self.name)))</cite>
…which, if you are curious, gets you the parent directory of the target
instance, wrapped in a new <cite>Directory</cite> instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.realpath">
<span class="sig-name descname"><span class="pre">realpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.abc.BaseFSName.realpath" title="Permalink to this definition"></a></dt>
<dd><p>Sugar for calling <cite>os.path.realpath(self.name)</cite> with additional
assurances that the path string in question will be UTF-8 Unicode
data and not a byte-string type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.relparent">
<span class="sig-name descname"><span class="pre">relparent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.abc.BaseFSName.relparent" title="Permalink to this definition"></a></dt>
<dd><p>Relativize a path, relative to its directory parent, and return it
as a string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.relprefix">
<span class="sig-name descname"><span class="pre">relprefix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'_'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.abc.BaseFSName.relprefix" title="Permalink to this definition"></a></dt>
<dd><p>Return a “prefix” string based on a file path – the actual path
separators are replaced with underscores, with which individual
path segments are joined, creating a single long string that is
unique to the original filesystem path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.split">
<span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.abc.BaseFSName.split" title="Permalink to this definition"></a></dt>
<dd><p>Return a two-tuple containing <cite>(dirname, basename)</cite> – like e.g.
for <cite>/yo/dogg/i/heard/youlike</cite>, your return value will be like
<cite>(Directory(“/yo/dogg/i/heard”), “youlike”)</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.abc.BaseFSName.symlink">
<span class="sig-name descname"><span class="pre">symlink</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.abc.BaseFSName.symlink" title="Permalink to this definition"></a></dt>
<dd><p>Create a symlink at <cite>destination</cite>, pointing to this instances’
path location (or an alternative source path, if specified).</p>
<p>The <cite>destination</cite> argument can be anything path-like: instances of
<cite>str</cite>, <cite>unicode</cite>, <cite>bytes</cite>, <cite>bytearray</cite>, <cite>pathlib.Path</cite>, <cite>os.PathLike</cite>,
or anything with an <cite>__fspath__(…)</cite> method – which this includes
<cite>clu.fs.filesystem.TemporaryName</cite> and <cite>clu.fs.filesystem.Directory</cite>
instances and relevant derived-type instances thereof.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.abc.TemporaryFileWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.abc.</span></span><span class="sig-name descname"><span class="pre">TemporaryFileWrapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.abc.TemporaryFileWrapper" title="Permalink to this definition"></a></dt>
<dd><p>Local subclass of <cite>tempfile._TemporaryFileWrapper</cite>.</p>
<p>We also inherit from both <cite>contextlib.AbstractContextManager</cite>
and the <cite>os.PathLike</cite> abstract bases – the latter requires
that we implement an <cite>__fspath__(…)</cite> method (q.v. implementation,
sub.) – and additionally, <cite>clu.fs.abc.TypeLocker</cite> is named as
the metaclass (q.v. metaclass <cite>__new__(…)</cite> implementation supra.)
to cache its type and register it as an os.PathLike subclass.</p>
<p>… Basically a better deal than the original ancestor, like
all-around. Plus it does not have a name prefixed with an
underscore, which if it’s not your implementation dogg that
can be a bit lexically irritating.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.abc.TypeLocker">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.abc.</span></span><span class="sig-name descname"><span class="pre">TypeLocker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.abc.TypeLocker" title="Permalink to this definition"></a></dt>
<dd><p><cite>clu.fs.abc.TypeLocker</cite> is a metaclass that does two things
with the types for whom it is designated as meta:</p>
<ol class="arabic simple">
<li><p>It keeps an index of those types in a dictionary member of
the <cite>TypeLocker</cite> metaclass itself; and</p></li>
<li><p>During class creation – the call to <cite>TypeLocker.__new__(…)</cite> –
it installs a class method called “directory(…)” that will,
when invoked, always return a new <cite>Directory</cite> instance that has
been initialized with the one provided argument “pth” (if one
was passed).</p></li>
</ol>
<p>… The point of this is to allow any of the classes throughout the
“clu.fs” subpackage, regardless of where they are defined or from
whom they inherit, to make use of cheaply-constructed <cite>Directory</cite>
instances wherever convenient.</p>
<p>Because the “directory(…)” method installed by <cite>TypeLocker</cite> performs
a lazy-lookup of the <cite>Directory</cite> class, using its own type index dict,
the order of definition does not matter i.e. the <cite>TemporaryName</cite> class
(q.v. definition immediately sub.) can use Directories despite its
definition occuring before <cite>Directory</cite> – in fact <cite>TemporaryName</cite> itself
is utilized within at least one <cite>Directory</cite> method – sans any issues.</p>
</dd></dl>

<span class="target" id="module-clu.fs.appdirectories"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.appdirectories.</span></span><span class="sig-name descname"><span class="pre">AppDirs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs" title="Permalink to this definition"></a></dt>
<dd><p>Convenience wrapper for getting application dirs.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.determine_system_string">
<span class="sig-name descname"><span class="pre">determine_system_string</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.determine_system_string" title="Permalink to this definition"></a></dt>
<dd><p>Determine upon which system this AppDirs instance has been brought
into existence – DEPRECIATED, see the appdirectories.System enum
class (and the System.determine() class method in particular) for
the replcaement logic</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.determine_win_folder_function">
<span class="sig-name descname"><span class="pre">determine_win_folder_function</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.determine_win_folder_function" title="Permalink to this definition"></a></dt>
<dd><p>Use successive imports to determine the best folder-finding method
to employ on Windows.</p>
<p>These are all dummy imports – they differ from actual (albiet similar
and related) modules imported by each of the respective Windows-native
functions; that’s why we delete whatever we managed to import before
returning the function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.get_site_config_dir">
<span class="sig-name descname"><span class="pre">get_site_config_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appauthor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.get_site_config_dir" title="Permalink to this definition"></a></dt>
<dd><p>Return full path to the user-shared data dir for this application.</p>
<blockquote>
<div><dl class="simple">
<dt>“appname” is the name of application.</dt><dd><p>If None, just the system directory is returned.</p>
</dd>
<dt>“appauthor” (only used on Windows) is the name of the</dt><dd><p>appauthor or distributing body for this application. Typically
it is the owning company name. This falls back to appname. You may
pass False to disable it.</p>
</dd>
<dt>“version” is an optional version path element to append to the</dt><dd><p>path. You might want to use this if you want multiple versions
of your app to be able to run independently. If used, this
would typically be “&lt;major&gt;.&lt;minor&gt;”.
Only applied when appname is present.</p>
</dd>
<dt>“multipath” is an optional parameter only applicable to <a href="#id4"><span class="problematic" id="id5">*</span></a>nix</dt><dd><p>which indicates that the entire list of config dirs should be
returned. By default, the first item from XDG_CONFIG_DIRS is
returned, or ‘/etc/xdg/&lt;AppName&gt;’, if XDG_CONFIG_DIRS is not set</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Typical site config directories are:</dt><dd><p>Mac OS X:   same as site_data_dir
Unix:       /etc/xdg/&lt;AppName&gt; or $XDG_CONFIG_DIRS[i]/&lt;AppName&gt; for each value in</p>
<blockquote>
<div><p>$XDG_CONFIG_DIRS</p>
</div></blockquote>
<p>Win <em>:      same as site_data_dir
Vista:      (Fail! “C:ProgramData” is a hidden *system</em> directory on Vista.)</p>
</dd>
</dl>
<p>For Unix, this is using the $XDG_CONFIG_DIRS[0] default, if multipath=False</p>
<p>WARNING: Do not use this on Windows. See the Vista-Fail note above for why.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.get_site_data_dir">
<span class="sig-name descname"><span class="pre">get_site_data_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appauthor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multipath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.get_site_data_dir" title="Permalink to this definition"></a></dt>
<dd><p>Return full path to the user-shared data dir for this application.</p>
<blockquote>
<div><dl class="simple">
<dt>“appname” is the name of application.</dt><dd><p>If None, just the system directory is returned.</p>
</dd>
<dt>“appauthor” (only used on Windows) is the name of the</dt><dd><p>appauthor or distributing body for this application. Typically
it is the owning company name. This falls back to appname. You may
pass False to disable it.</p>
</dd>
<dt>“version” is an optional version path element to append to the</dt><dd><p>path. You might want to use this if you want multiple versions
of your app to be able to run independently. If used, this
would typically be “&lt;major&gt;.&lt;minor&gt;”.
Only applied when appname is present.</p>
</dd>
<dt>“multipath” is an optional parameter only applicable to <a href="#id6"><span class="problematic" id="id7">*</span></a>nix</dt><dd><p>which indicates that the entire list of data dirs should be
returned. By default, the first item from XDG_DATA_DIRS is
returned, or ‘/usr/local/share/&lt;AppName&gt;’,
if XDG_DATA_DIRS is not set</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Typical site data directories are:</dt><dd><p>Mac OS X:   /Library/Application Support/&lt;AppName&gt;
Unix:       /usr/local/share/&lt;AppName&gt; or /usr/share/&lt;AppName&gt;
Win XP:     C:Documents and SettingsAll UsersApplication Data&lt;AppAuthor&gt;&lt;AppName&gt;
Vista:      (Fail! “C:ProgramData” is a hidden <em>system</em> directory on Vista.)
Win 7:      C:ProgramData&lt;AppAuthor&gt;&lt;AppName&gt;   # Hidden, but writeable on Win 7.</p>
</dd>
</dl>
<p>For Unix, this is using the $XDG_DATA_DIRS[0] default.</p>
<p>WARNING: Do not use this on Windows. See the Vista-Fail note above for why.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.get_user_cache_dir">
<span class="sig-name descname"><span class="pre">get_user_cache_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appauthor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opinion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.get_user_cache_dir" title="Permalink to this definition"></a></dt>
<dd><p>Return full path to the user-specific cache dir for this application.</p>
<blockquote>
<div><dl class="simple">
<dt>“appname” is the name of application.</dt><dd><p>If None, just the system directory is returned.</p>
</dd>
<dt>“appauthor” (only used on Windows) is the name of the</dt><dd><p>appauthor or distributing body for this application. Typically
it is the owning company name. This falls back to appname. You may
pass False to disable it.</p>
</dd>
<dt>“version” is an optional version path element to append to the</dt><dd><p>path. You might want to use this if you want multiple versions
of your app to be able to run independently. If used, this
would typically be “&lt;major&gt;.&lt;minor&gt;”.
Only applied when appname is present.</p>
</dd>
<dt>“opinion” (boolean) can be False to disable the appending of</dt><dd><p>“Cache” to the base app data dir for Windows. See
discussion below.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Typical user cache directories are:</dt><dd><p>Mac OS X:   ~/Library/Caches/&lt;AppName&gt;
Unix:       ~/.cache/&lt;AppName&gt; (XDG default)
Win XP:     C:Documents and Settings&lt;username&gt;Local SettingsApplication Data&lt;AppAuthor&gt;&lt;AppName&gt;Cache
Vista:      C:Users&lt;username&gt;AppDataLocal&lt;AppAuthor&gt;&lt;AppName&gt;Cache</p>
</dd>
</dl>
<p>On Windows the only suggestion in the MSDN docs is that local settings go in
the <cite>CSIDL_LOCAL_APPDATA</cite> directory. This is identical to the non-roaming
app data dir (the default returned by <cite>user_data_dir</cite> above). Apps typically
put cache data somewhere <em>under</em> the given dir here. Some examples:</p>
<blockquote>
<div><p>…MozillaFirefoxProfiles&lt;ProfileName&gt;Cache
…AcmeSuperAppCache1.0</p>
</div></blockquote>
<p>OPINION: This function appends “Cache” to the <cite>CSIDL_LOCAL_APPDATA</cite> value.
This can be disabled with the <cite>opinion=False</cite> option.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.get_user_config_dir">
<span class="sig-name descname"><span class="pre">get_user_config_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appauthor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roaming</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.get_user_config_dir" title="Permalink to this definition"></a></dt>
<dd><p>Return full path to the user-specific config dir for this application.</p>
<blockquote>
<div><dl class="simple">
<dt>“appname” is the name of application.</dt><dd><p>If None, just the system directory is returned.</p>
</dd>
<dt>“appauthor” (only used on Windows) is the name of the</dt><dd><p>appauthor or distributing body for this application. Typically
it is the owning company name. This falls back to appname. You may
pass False to disable it.</p>
</dd>
<dt>“version” is an optional version path element to append to the</dt><dd><p>path. You might want to use this if you want multiple versions
of your app to be able to run independently. If used, this
would typically be “&lt;major&gt;.&lt;minor&gt;”.
Only applied when appname is present.</p>
</dd>
<dt>“roaming” (boolean, default False) can be set True to use the Windows</dt><dd><p>roaming appdata directory. That means that for users on a Windows
network setup for roaming profiles, this user data will be
sync’d on login. See
&lt;<a class="reference external" href="http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx">http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx</a>&gt;
for a discussion of issues.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Typical user config directories are:</dt><dd><p>Mac OS X:               ~/Library/Preferences/&lt;AppName&gt;
Unix:                   ~/.config/&lt;AppName&gt;     # or in $XDG_CONFIG_HOME, if defined
Win <a href="#id8"><span class="problematic" id="id9">*</span></a>:                  same as user_data_dir</p>
</dd>
</dl>
<p>For Unix, we follow the XDG spec and support $XDG_CONFIG_HOME.
That means, by default “~/.config/&lt;AppName&gt;”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.get_user_data_dir">
<span class="sig-name descname"><span class="pre">get_user_data_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appauthor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roaming</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.get_user_data_dir" title="Permalink to this definition"></a></dt>
<dd><p>Return full path to the user-specific data dir for this application.</p>
<blockquote>
<div><dl class="simple">
<dt>“appname” is the name of application.</dt><dd><p>If None, just the system directory is returned.</p>
</dd>
<dt>“appauthor” (only used on Windows) is the name of the</dt><dd><p>appauthor or distributing body for this application. Typically
it is the owning company name. This falls back to appname. You may
pass False to disable it.</p>
</dd>
<dt>“version” is an optional version path element to append to the</dt><dd><p>path. You might want to use this if you want multiple versions
of your app to be able to run independently. If used, this
would typically be “&lt;major&gt;.&lt;minor&gt;”.
Only applied when appname is present.</p>
</dd>
<dt>“roaming” (boolean, default False) can be set True to use the Windows</dt><dd><p>roaming appdata directory. That means that for users on a Windows
network setup for roaming profiles, this user data will be
sync’d on login. See
&lt;<a class="reference external" href="http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx">http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx</a>&gt;
for a discussion of issues.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Typical user data directories are:</dt><dd><p>Mac OS X:               ~/Library/Application Support/&lt;AppName&gt;
Unix:                   ~/.local/share/&lt;AppName&gt;    # or in $XDG_DATA_HOME, if defined
Win XP (not roaming):   C:Documents and Settings&lt;username&gt;Application Data&lt;AppAuthor&gt;&lt;AppName&gt;
Win XP (roaming):       C:Documents and Settings&lt;username&gt;Local SettingsApplication Data&lt;AppAuthor&gt;&lt;AppName&gt;
Win 7  (not roaming):   C:Users&lt;username&gt;AppDataLocal&lt;AppAuthor&gt;&lt;AppName&gt;
Win 7  (roaming):       C:Users&lt;username&gt;AppDataRoaming&lt;AppAuthor&gt;&lt;AppName&gt;</p>
</dd>
</dl>
<p>For Unix, we follow the XDG spec and support $XDG_DATA_HOME.
That means, by default “~/.local/share/&lt;AppName&gt;”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.get_user_log_dir">
<span class="sig-name descname"><span class="pre">get_user_log_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appauthor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opinion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.get_user_log_dir" title="Permalink to this definition"></a></dt>
<dd><p>Return full path to the user-specific log dir for this application.</p>
<blockquote>
<div><dl class="simple">
<dt>“appname” is the name of application.</dt><dd><p>If None, just the system directory is returned.</p>
</dd>
<dt>“appauthor” (only used on Windows) is the name of the</dt><dd><p>appauthor or distributing body for this application. Typically
it is the owning company name. This falls back to appname. You may
pass False to disable it.</p>
</dd>
<dt>“version” is an optional version path element to append to the</dt><dd><p>path. You might want to use this if you want multiple versions
of your app to be able to run independently. If used, this
would typically be “&lt;major&gt;.&lt;minor&gt;”.
Only applied when appname is present.</p>
</dd>
<dt>“opinion” (boolean) can be False to disable the appending of</dt><dd><p>“Logs” to the base app data dir for Windows, and “log” to the
base cache dir for Unix. See discussion below.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Typical user log directories are:</dt><dd><p>Mac OS X:   ~/Library/Logs/&lt;AppName&gt;
Unix:       ~/.cache/&lt;AppName&gt;/log  # or under $XDG_CACHE_HOME if defined
Win XP:     C:Documents and Settings&lt;username&gt;Local SettingsApplication Data&lt;AppAuthor&gt;&lt;AppName&gt;Logs
Vista:      C:Users&lt;username&gt;AppDataLocal&lt;AppAuthor&gt;&lt;AppName&gt;Logs</p>
</dd>
</dl>
<p>On Windows the only suggestion in the MSDN docs is that local settings
go in the <cite>CSIDL_LOCAL_APPDATA</cite> directory. (Note: I’m interested in
examples of what some windows apps use for a logs dir.)</p>
<p>OPINION: This function appends “Logs” to the <cite>CSIDL_LOCAL_APPDATA</cite>
value for Windows and appends “log” to the user cache dir for Unix.
This can be disabled with the <cite>opinion=False</cite> option.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.get_user_state_dir">
<span class="sig-name descname"><span class="pre">get_user_state_dir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appauthor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">version</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roaming</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.get_user_state_dir" title="Permalink to this definition"></a></dt>
<dd><p>Return full path to the user-specific state dir for this application.</p>
<blockquote>
<div><dl class="simple">
<dt>“appname” is the name of application.</dt><dd><p>If None, just the system directory is returned.</p>
</dd>
<dt>“appauthor” (only used on Windows) is the name of the</dt><dd><p>appauthor or distributing body for this application. Typically
it is the owning company name. This falls back to appname. You may
pass False to disable it.</p>
</dd>
<dt>“version” is an optional version path element to append to the</dt><dd><p>path. You might want to use this if you want multiple versions
of your app to be able to run independently. If used, this
would typically be “&lt;major&gt;.&lt;minor&gt;”.
Only applied when appname is present.</p>
</dd>
<dt>“roaming” (boolean, default False) can be set True to use the Windows</dt><dd><p>roaming appdata directory. That means that for users on a Windows
network setup for roaming profiles, this user data will be
sync’d on login. See
&lt;<a class="reference external" href="http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx">http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx</a>&gt;
for a discussion of issues.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Typical user state directories are:</dt><dd><p>Mac OS X:  same as user_data_dir
Unix:      ~/.local/state/&lt;AppName&gt;   # or in $XDG_STATE_HOME, if defined
Win <a href="#id10"><span class="problematic" id="id11">*</span></a>:     same as user_data_dir</p>
</dd>
</dl>
<p>For Unix, we follow this Debian proposal &lt;<a class="reference external" href="https://wiki.debian.org/XDGBaseDirectorySpecification#state">https://wiki.debian.org/XDGBaseDirectorySpecification#state</a>&gt;
to extend the XDG spec and support $XDG_STATE_HOME.</p>
<p>That means, by default “~/.local/state/&lt;AppName&gt;”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.get_win_folder">
<span class="sig-name descname"><span class="pre">get_win_folder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">argument</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.get_win_folder" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve the module-private Win32 API access function from
the AppDirs instance (so as not to invoke it as a bound method)
before calling it with the supplied argument</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.site_config_dir">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">site_config_dir</span></span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.site_config_dir" title="Permalink to this definition"></a></dt>
<dd><p>The system-wide configuration directory</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.site_data_dir">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">site_data_dir</span></span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.site_data_dir" title="Permalink to this definition"></a></dt>
<dd><p>The system-wide application-specific data directory</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.to_string">
<span class="sig-name descname"><span class="pre">to_string</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.to_string" title="Permalink to this definition"></a></dt>
<dd><p>Stringify the AppDirs instance.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.user_cache_dir">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">user_cache_dir</span></span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.user_cache_dir" title="Permalink to this definition"></a></dt>
<dd><p>The userland cache directory</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.user_config_dir">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">user_config_dir</span></span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.user_config_dir" title="Permalink to this definition"></a></dt>
<dd><p>The userland configuration directory</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.user_data_dir">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">user_data_dir</span></span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.user_data_dir" title="Permalink to this definition"></a></dt>
<dd><p>The userland application-specific data directory</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.user_log_dir">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">user_log_dir</span></span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.user_log_dir" title="Permalink to this definition"></a></dt>
<dd><p>The userland log directory</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.AppDirs.user_state_dir">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">user_state_dir</span></span><a class="headerlink" href="#clu.fs.appdirectories.AppDirs.user_state_dir" title="Permalink to this definition"></a></dt>
<dd><p>The userland state-stash directory</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.appdirectories.CSIDL">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.appdirectories.</span></span><span class="sig-name descname"><span class="pre">CSIDL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.CSIDL" title="Permalink to this definition"></a></dt>
<dd><p>An enumeration encapsulating Windows CSIDLs.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.CSIDL.for_name">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">for_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.CSIDL.for_name" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a CSIDL by name (case-insensitively)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.CSIDL.fullname">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fullname</span></span><a class="headerlink" href="#clu.fs.appdirectories.CSIDL.fullname" title="Permalink to this definition"></a></dt>
<dd><p>A CSIDL’s “full name” – which is basically of the form “CSIDL_NAME_STRING”</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.CSIDL.to_int">
<span class="sig-name descname"><span class="pre">to_int</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.CSIDL.to_int" title="Permalink to this definition"></a></dt>
<dd><p>A given CSIDL’s integer value</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.CSIDL.to_string">
<span class="sig-name descname"><span class="pre">to_string</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.CSIDL.to_string" title="Permalink to this definition"></a></dt>
<dd><p>A given CSIDL’s full name</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.appdirectories.System">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.appdirectories.</span></span><span class="sig-name descname"><span class="pre">System</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.System" title="Permalink to this definition"></a></dt>
<dd><p>An enumeration class for dealing with the name of the
underlying operating system upon which we are running.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.System.all">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.System.all" title="Permalink to this definition"></a></dt>
<dd><p>Get a generator over all System values</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.System.determine">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">determine</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.System.determine" title="Permalink to this definition"></a></dt>
<dd><p>Determine the System value for the current platform</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.System.from_string">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.System.from_string" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a System value by name (case-insensitively)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.System.is_current">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_current</span></span><a class="headerlink" href="#clu.fs.appdirectories.System.is_current" title="Permalink to this definition"></a></dt>
<dd><p>A boolean value expressing if a given System value
represents the current running operating system</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.System.is_unix_based">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_unix_based</span></span><a class="headerlink" href="#clu.fs.appdirectories.System.is_unix_based" title="Permalink to this definition"></a></dt>
<dd><p>A boolean value expressing if a given System value
represents a UNIX-based operating system</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.System.match">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.System.match" title="Permalink to this definition"></a></dt>
<dd><p>Match a system to a value – the nature of which can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>a string (unicode or bytes-type) naming the system;</p></li>
<li><p>an existing “System” enum-member value; or</p></li>
<li><p>an arbitrary alternative enum-member value.</p></li>
</ul>
</div></blockquote>
<p>… The matched system is returned. If no match is found,
a ValueError will be raised.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.System.os_name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">os_name</span></span><a class="headerlink" href="#clu.fs.appdirectories.System.os_name" title="Permalink to this definition"></a></dt>
<dd><p>A given System value’s “os_name” (as reported when
running within a java-based environment e.g. Jython)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.appdirectories.System.sys_name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sys_name</span></span><a class="headerlink" href="#clu.fs.appdirectories.System.sys_name" title="Permalink to this definition"></a></dt>
<dd><p>A given System value’s name, lowercased</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.System.to_string">
<span class="sig-name descname"><span class="pre">to_string</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.System.to_string" title="Permalink to this definition"></a></dt>
<dd><p>A given System value’s name</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.appdirectories.System.unixes">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">unixes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.System.unixes" title="Permalink to this definition"></a></dt>
<dd><p>Get a generator over the UNIX-based System values</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.appdirectories.clu_appdirs">
<span class="sig-prename descclassname"><span class="pre">clu.fs.appdirectories.</span></span><span class="sig-name descname"><span class="pre">clu_appdirs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">System.LINUX2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">versioning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.appdirectories.clu_appdirs" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve an AppDirs instance specific to the CLU project</p>
</dd></dl>

<span class="target" id="module-clu.fs.filesystem"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">Directory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory" title="Permalink to this definition"></a></dt>
<dd><p>A context-managed directory: change in on enter, change back out
on exit. Plus a few convenience functions for listing and whatnot.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a cloned copy of this instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.copy_all">
<span class="sig-name descname"><span class="pre">copy_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">destination</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.copy_all" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Copy the entire directory tree, all contents included, to a new</dt><dd><p>destination path. The destination must not already exist, and</p>
</dd>
<dt><cite>copy_all(…)</cite> will not overwrite existant directories. Like, if</dt><dd><p>you have yourself an instance of Directory, <cite>directory</cite>, and you
want to copy it to <cite>/home/me/myshit</cite>, <cite>/home/me</cite> should already
exist but <cite>/home/me/myshit</cite> should not, as the subdirectory</p>
</dd>
<dt><cite>myshit</cite> gets created by the <cite>directory.copy_all(‘/home/me/myshit’)</cite></dt><dd><p>invocation (like as a side-effect).</p>
<p>Does that make sense to you? Try it, you’ll get a <cite>FilesystemError</cite>
if it evidently did not make sense to you.</p>
<p>The destination path may be specified using a string-like, with
another Directory object, or anything deemed path-y enough by</p>
</dd>
<dt><cite>os.fspath(…)</cite>. Internally, this method uses <cite>shutil.copytree(…)</cite></dt><dd><p>to tell the filesystem what to copy where.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.ctx_initialize">
<span class="sig-name descname"><span class="pre">ctx_initialize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.ctx_initialize" title="Permalink to this definition"></a></dt>
<dd><p>Restores the instance to the freshly-allocated state – with one
notable exception: if it had been previously prepared (through a
call to <cite>instance.ctx_prepare()</cite>) and thus has a “new” attribute
filled in with a target path, <cite>ctx_initialize()</cite> will preserve
the contents of that attribute in the value of the <cite>self.target</cite> 
instance member.</p>
<p>The call deletes all other instance attributes from the internal
mapping of the instance in question, leaving it in a state ready
for either context-managed reëntry, or for reuse in an unmanaged
fashion <em>provided</em> one firstly calls <cite>instance.ctx_set_targets()</cite>
or <cite>instance.ctx_prepare()</cite> in order to reconfigure (the minimal
subset of, or the full complement of) the member-variable values
needed by the internal workings of a Directory instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.ctx_prepare">
<span class="sig-name descname"><span class="pre">ctx_prepare</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.ctx_prepare" title="Permalink to this definition"></a></dt>
<dd><p>Prepares the member values of the Directory instance according
to a requisite <cite>self.target</cite> directory-path value; the primary
logic performed by this function determines whether or not it
is necessary to switch the process working directory while the
Directory instance is actively being used as a context manager
in the scope of a <cite>while</cite> block.</p>
<p>The reason this is done herein is to minimize the number of
calls to potentially expensive system-call-wrapping functions
such as <cite>os.getcwd()</cite>, <cite>os.path.samefile(…)</cite>, and especially
<cite>os.chdir(…)</cite> – which the use of the latter affects the state
of the process issuing the call in a global fashion, and can
cause invincibly undebuggable behavioral oddities to crop up
in a variety of circumstances.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.ctx_set_targets">
<span class="sig-name descname"><span class="pre">ctx_set_targets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.ctx_set_targets" title="Permalink to this definition"></a></dt>
<dd><p>Sets the “self.old” and “self.new” instance variable values,
using the value of <cite>self.target</cite> and an (optional) string-like
argument to use as the value for “self.old”.</p>
<p>One shouldn’t generally call this or have a need to call this –
although one can manually invoke <cite>instance.ctx_set_targets(…)</cite>
to reconfigure a Directory instance to use it again after it has
been re-initialized after a call to <cite>instance.ctx_initialize()</cite>
(q.v. <cite>ctx_initialize()</cite> help supra.) in cases where it isn’t
going to be used as part of a managed context; that is to say,
outside of a <cite>with</cite> statement.</p>
<p>(Within a <cite>with</cite> statement, the call issued upon scope entry to
<cite>Directory.__enter__(self)</cite> will internally make a call to
<cite>Directory.ctx_prepare(self)</cite> (q.v. doctext help sub.) which
that will call <cite>Directory.ctx_set_targets(self, …)</cite> itself.)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.exists">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">exists</span></span><a class="headerlink" href="#clu.fs.filesystem.Directory.exists" title="Permalink to this definition"></a></dt>
<dd><p>Whether or not the instances’ target path exists as a directory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.flatten">
<span class="sig-name descname"><span class="pre">flatten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.flatten" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Copy the entire directory tree, all contents included, to a new</dt><dd><p>destination path – with all files residing within the same directory
level.</p>
<p>That is to say, if the directory tree is like:</p>
<blockquote>
<div><p>yo/
yo/dogg/[0..9].jpg
yo/dogg/nodogg/[0..99].png</p>
</div></blockquote>
<p>… you end up with a single destination directory, filled with files,
all with names like:</p>
<blockquote>
<div><p>yo_dogg_[0..9].jpg
yo_dogg_nodogg_[0..99].png</p>
</div></blockquote>
</dd>
<dt><cite>flatten(…)</cite> will not overwrite existant directories. Like, if</dt><dd><p>you have yourself an instance of Directory, <cite>directory</cite>, and you
want to copy it to <cite>/home/me/myshit</cite>, <cite>/home/me</cite> should already
exist but <cite>/home/me/myshit</cite> should not, as the subdirectory</p>
</dd>
<dt><cite>myshit</cite> gets created by the <cite>directory.flatten(‘/home/me/myshit’)</cite></dt><dd><p>invocation (like as a side-effect).</p>
<p>Does that make sense to you? Try it, you’ll get a <cite>FilesystemError</cite>
if it evidently did not make sense to you.</p>
<p>The destination path may be specified using a string-like, with
another Directory object, or anything deemed path-y enough by</p>
</dd>
<dt><cite>os.fspath(…)</cite>. Internally, this method uses <cite>shutil.copy2(…)</cite></dt><dd><p>to tell the filesystem to copy and rename each file in succession.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.importables">
<span class="sig-name descname"><span class="pre">importables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subdir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'py'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excludes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('-',</span> <span class="pre">'+',</span> <span class="pre">'pytest',</span> <span class="pre">'legacy',</span> <span class="pre">'obsolete',</span> <span class="pre">'repl.py')</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.importables" title="Permalink to this definition"></a></dt>
<dd><p>List the importable file-based modules found within “subdir”,
matching the “suffix” string, and not matching any of the
“excludes” strings.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.initialized">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">initialized</span></span><a class="headerlink" href="#clu.fs.filesystem.Directory.initialized" title="Permalink to this definition"></a></dt>
<dd><p>Whether or not the instance has been “initialized” – as in, the
<cite>target</cite> instance value has been set (q.v. <cite>ctx_initialize(…)</cite>
help sub.) as it stands immediately after <cite>__init__(…)</cite> has run.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">a</span> <span class="pre">set-like</span> <span class="pre">object</span> <span class="pre">providing</span> <span class="pre">a</span> <span class="pre">view</span> <span class="pre">on</span> <span class="pre">D's</span> <span class="pre">items</span></span></span><a class="headerlink" href="#clu.fs.filesystem.Directory.items" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">a</span> <span class="pre">set-like</span> <span class="pre">object</span> <span class="pre">providing</span> <span class="pre">a</span> <span class="pre">view</span> <span class="pre">on</span> <span class="pre">D's</span> <span class="pre">keys</span></span></span><a class="headerlink" href="#clu.fs.filesystem.Directory.keys" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.ls">
<span class="sig-name descname"><span class="pre">ls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.ls" title="Permalink to this definition"></a></dt>
<dd><p>List files – defaults to the process’ current working directory.
As per the UNIX custom, files whose name begins with a dot are
omitted.</p>
<p>Specify an optional “suffix” parameter to filter the list by a
particular file suffix (leading dots unnecessary but unharmful).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.ls_la">
<span class="sig-name descname"><span class="pre">ls_la</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.ls_la" title="Permalink to this definition"></a></dt>
<dd><p>List all files, including files whose name starts with a dot.
The default is to use the process’ current working directory.</p>
<p>Specify an optional “suffix” parameter to filter the list by a
particular file suffix (leading dots unnecessary but unharmful).</p>
<p>(Technically speaking, <cite>ls_la()</cite> is a misnomer for this method,
as it does not provide any extended meta-info like you get if
you use the “-l” flag when invoking the <cite>ls</cite> command – I just
like calling it that because “ls -la” was one of the first shell
commands I ever learned, and it reads better than <cite>ls_a()</cite> which
I think looks awkward and goofy.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.makedirs">
<span class="sig-name descname"><span class="pre">makedirs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subpath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">493</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.makedirs" title="Permalink to this definition"></a></dt>
<dd><p>Creates any parts of the target directory path that don’t
already exist, á la the <cite>mkdir -p</cite> shell command.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#clu.fs.filesystem.Directory.name" title="Permalink to this definition"></a></dt>
<dd><p>The instances’ target directory path.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.prepared">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">prepared</span></span><a class="headerlink" href="#clu.fs.filesystem.Directory.prepared" title="Permalink to this definition"></a></dt>
<dd><p>Whether or not the instance has been internally prepared for use
(q.v. <cite>ctx_prepare()</cite> help sub.) and is in a valid state.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.subdirectory">
<span class="sig-name descname"><span class="pre">subdirectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subdir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.subdirectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the path to a subpath of the instances’ target path –
much like Directory.subpath(…) – as an instance of Directory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.subpath">
<span class="sig-name descname"><span class="pre">subpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subpath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">requisite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.subpath" title="Permalink to this definition"></a></dt>
<dd><p>Returns the path to a subpath of the instances’ target path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.suffix_histogram">
<span class="sig-name descname"><span class="pre">suffix_histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excludes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('~',</span> <span class="pre">'#',</span> <span class="pre">'ds_store',</span> <span class="pre">'.git')</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.suffix_histogram" title="Permalink to this definition"></a></dt>
<dd><p>Return a ‘collections.Counter’ filled with a histogram of the
file suffixes for all files found in the given subdirectory,
excluding anything matching any of the “excludes” strings.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.suffixes">
<span class="sig-name descname"><span class="pre">suffixes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">excludes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('~',</span> <span class="pre">'#',</span> <span class="pre">'ds_store',</span> <span class="pre">'.git')</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.suffixes" title="Permalink to this definition"></a></dt>
<dd><p>Return a generator over all the file suffixes of all files
found recursively within the given subdirectory, excluding
anything matching any of the “excludes” strings.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.targets_set">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">targets_set</span></span><a class="headerlink" href="#clu.fs.filesystem.Directory.targets_set" title="Permalink to this definition"></a></dt>
<dd><p>Whether or not the instance has had targets set (the <cite>new</cite> and <cite>old</cite>
instance values, q.v. <cite>ctx_set_targets(…)</cite> help sub.) and is ready
for context-managed use.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">an</span> <span class="pre">object</span> <span class="pre">providing</span> <span class="pre">a</span> <span class="pre">view</span> <span class="pre">on</span> <span class="pre">D's</span> <span class="pre">values</span></span></span><a class="headerlink" href="#clu.fs.filesystem.Directory.values" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.walk">
<span class="sig-name descname"><span class="pre">walk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">followlinks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.walk" title="Permalink to this definition"></a></dt>
<dd><p>Sugar for calling os.walk(self.name)</p>
<p>Note that the “followlinks” default here is True, whereas
the underlying function defaults to False for that argument.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.Directory.zip_archive">
<span class="sig-name descname"><span class="pre">zip_archive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compression_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Directory.zip_archive" title="Permalink to this definition"></a></dt>
<dd><p>Recursively descends through the target directory, stowing all
that it finds into a zipfile at the specified destination path.</p>
<p>Use the optional “compression_mode” parameter to specify the
compression algorithm, as per the constants found in the <cite>zipfile</cite>
module; the default value is <cite>zipfile.ZIP_DEFLATED</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.filesystem.Intermediate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">Intermediate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">change</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.Intermediate" title="Permalink to this definition"></a></dt>
<dd><p>clu.fs.filesystem.Intermediate isn’t a class, per se – rather,
it is a class factory proxy that normally constructs a new Directory
instance in leu of itself, except for when it it is constructed without
a <cite>pth</cite> argument, in which case, it falls back to the construction of
a new TemporaryDirectory instance instead.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.filesystem.NamedTemporaryFile">
<span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">NamedTemporaryFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'w+b'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tmp'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'yo-dogg-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.NamedTemporaryFile" title="Permalink to this definition"></a></dt>
<dd><p>Variation on <code class="docutils literal notranslate"><span class="pre">tempfile.NamedTemporaryFile(…)</span></code>, such that suffixes
are passed WITHOUT specifying the period in front (versus the
standard library version which makes you pass suffixes WITH
the fucking period, ugh).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryDirectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">TemporaryDirectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'TemporaryDirectory-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">change</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryDirectory" title="Permalink to this definition"></a></dt>
<dd><p>It’s funny how this code looks, like, 99 percent exactly like the above
TemporaryName class – shit just works out that way. But this actually
creates the directory in question; much like filesystem::TemporaryDirectory
from <cite>libimread</cite>, this class wraps tempfile.mkdtemp() and can be used as
a context manager (the C++ orig used RAII).</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryDirectory.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryDirectory.close" title="Permalink to this definition"></a></dt>
<dd><p>Delete the directory pointed to by the TemporaryDirectory
instance, and everything it contains. USE WITH CAUTION.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryDirectory.ctx_prepare">
<span class="sig-name descname"><span class="pre">ctx_prepare</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryDirectory.ctx_prepare" title="Permalink to this definition"></a></dt>
<dd><p>Prepares the member values of the Directory instance according
to a requisite <cite>self.target</cite> directory-path value; the primary
logic performed by this function determines whether or not it
is necessary to switch the process working directory while the
Directory instance is actively being used as a context manager
in the scope of a <cite>while</cite> block.</p>
<p>The reason this is done herein is to minimize the number of
calls to potentially expensive system-call-wrapping functions
such as <cite>os.getcwd()</cite>, <cite>os.path.samefile(…)</cite>, and especially
<cite>os.chdir(…)</cite> – which the use of the latter affects the state
of the process issuing the call in a global fashion, and can
cause invincibly undebuggable behavioral oddities to crop up
in a variety of circumstances.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryDirectory.destroy">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">destroy</span></span><a class="headerlink" href="#clu.fs.filesystem.TemporaryDirectory.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Whether or not the TemporaryDirectory instance has been marked
for automatic deletion upon scope exit (q.v __exit__(…) method
definition sub.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryDirectory.do_not_destroy">
<span class="sig-name descname"><span class="pre">do_not_destroy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryDirectory.do_not_destroy" title="Permalink to this definition"></a></dt>
<dd><p>Mark this TemporaryDirectory instance as one that should not
be automatically destroyed upon the scope exit for the instance.</p>
<p>This function returns the temporary directory path, and may
be called more than once without further side effects.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryDirectory.exists">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">exists</span></span><a class="headerlink" href="#clu.fs.filesystem.TemporaryDirectory.exists" title="Permalink to this definition"></a></dt>
<dd><p>Whether or not the temporary directory exists.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryDirectory.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#clu.fs.filesystem.TemporaryDirectory.name" title="Permalink to this definition"></a></dt>
<dd><p>The temporary directory pathname.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryDirectory.symlink">
<span class="sig-name descname"><span class="pre">symlink</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryDirectory.symlink" title="Permalink to this definition"></a></dt>
<dd><p>Symlinking to TemporaryDirectory instances is disabled –
why do you want to symlink to something that is about
to delete itself?? That is just asking for a whole bunch of
dangling references dogg.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">TemporaryName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tmp'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName" title="Permalink to this definition"></a></dt>
<dd><p>This is like <cite>NamedTemporaryFile</cite> without any of the actual stuff;
it just makes up a file name – YOU have to make shit happen with it.
But: should you cause such scatalogical events to transpire, this
class (when instanced as a context manager) will clean it up for you.
Unless you say not to. Really it’s your call dogg, I could give AF</p>
<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.binary_mode">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">binary_mode</span></span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.binary_mode" title="Permalink to this definition"></a></dt>
<dd><p>Whether or not the mode with which this TemporaryName instance was 
constructed is a “binary mode” – and as such, requires the operands
passed to its <cite>write(…)</cite> methods of its filehandle (q.v. the “mode”
property definition supra., and the “filehandle” property definition
sub.) to be of type <cite>byte</cite> or <cite>bytearray</cite>, or of a type either derived
or compatible with these. Errors will be raised if you try to call a
<cite>write(…)</cite> method with a <cite>str</cite>-ish operand.</p>
<p>Filehandles constructed through “non-binary” TemporaryName instances
are the other way around – their <cite>write(…)</cite> methods can only be passed
instances of <cite>str</cite> (or, <cite>unicode</cite>, for those Python-2 diehards still
remaining amongst us) or similar; attempt to pass anything <cite>byte</cite>-y
and you’ll get raised on.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.close" title="Permalink to this definition"></a></dt>
<dd><p>Destroys any existing file at this instances’ file path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">destination</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.copy" title="Permalink to this definition"></a></dt>
<dd><p>Copy the file (if one exists) at the instances’ file path
to a new destination.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.destroy">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">destroy</span></span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.destroy" title="Permalink to this definition"></a></dt>
<dd><p>Whether or not this TemporaryName instance should destroy any file
that should happen to exist at its temporary file path (as per its
“name” attribute) on scope exit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.do_not_destroy">
<span class="sig-name descname"><span class="pre">do_not_destroy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.do_not_destroy" title="Permalink to this definition"></a></dt>
<dd><p>Mark this TemporaryName instance as one that should not be automatically
destroyed upon the scope exit for the instance.</p>
<p>This function returns the temporary file path, and may be called more
than once without further side effects.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.filehandle">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">filehandle</span></span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.filehandle" title="Permalink to this definition"></a></dt>
<dd><p>Access a “clu.fs.abc.TemporaryNamedFile” instance, opened and ready
to read and write, for this TemporaryName instances’ file path.</p>
<p>While this is a normal property descriptor – each time it is accessed,
its function is called anew – the underlying <cite>TemporaryNamedFile</cite> call
is a cached function and not a class constructor (despite what you might
think because of that CamelCased identifier). That means you’ll almost
certainly be given the same instance whenever you access the “filehandle”
property (which is less fraught with potentially confusing weirdness,
I do believe).</p>
<p>Accessing this property delegates the responsibility for destroying
the TemporaryName file contents to the TemporaryNamedFile object –
saving the TemporaryNamedFile in, like, a variable somewhere and then
letting the original TemporaryName go out of scope will keep the file
alive and unclosed, for example. THE UPSHOT: be sure to call “close()”
on the filehandle instance you use. That’s fair, right? I think that’s
totally fair to do it like that, OK.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.filesize">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">filesize</span></span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.filesize" title="Permalink to this definition"></a></dt>
<dd><p>The filesize for the temporary file</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.flags">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">flags</span></span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.flags" title="Permalink to this definition"></a></dt>
<dd><p>A flag value matching the instances’ mode and deletion disposition.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.mode">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mode</span></span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.mode" title="Permalink to this definition"></a></dt>
<dd><p>Get the mode string for this TemporaryName instance. This is used
if and when a filehandle is accessed (q.v. “filehandle” property
definition sub.) in the construction of the TemporaryNamedFile that
is handed back as the filehandle instance.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.name" title="Permalink to this definition"></a></dt>
<dd><p>The temporary file path (which initially does not exist).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.read">
<span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">original_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.read" title="Permalink to this definition"></a></dt>
<dd><p>Read data from the temporary name, if it points to an existing file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.symlink">
<span class="sig-name descname"><span class="pre">symlink</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.symlink" title="Permalink to this definition"></a></dt>
<dd><p>Symlinking to TemporaryName instances is disabled –
why do you want to symlink to something that is about
to delete itself?? That is just asking for a whole bunch of
dangling references dogg.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.fs.filesystem.TemporaryName.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.TemporaryName.write" title="Permalink to this definition"></a></dt>
<dd><p>Write data to the temporary name using a context-managed handle</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.filesystem.cd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">cd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.cd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.filesystem.ensure_path_is_valid">
<span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">ensure_path_is_valid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.ensure_path_is_valid" title="Permalink to this definition"></a></dt>
<dd><p>Raise an exception if we can’t write to the specified path</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.filesystem.hd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">hd</span></span><a class="headerlink" href="#clu.fs.filesystem.hd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.filesystem.rm_rf">
<span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">rm_rf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.rm_rf" title="Permalink to this definition"></a></dt>
<dd><p>rm_rf() does what <cite>rm -rf</cite> does – so, for the love of fuck,
BE FUCKING CAREFUL WITH IT.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.filesystem.script_path">
<span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">script_path</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.script_path" title="Permalink to this definition"></a></dt>
<dd><p>Return the path to the embedded scripts directory.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.filesystem.td">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">td</span></span><a class="headerlink" href="#clu.fs.filesystem.td" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.fs.filesystem.wd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">wd</span></span><a class="headerlink" href="#clu.fs.filesystem.wd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.filesystem.which">
<span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">which</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathvar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.which" title="Permalink to this definition"></a></dt>
<dd><p>Deduces the path corresponding to an executable name,
as per the UNIX command <cite>which</cite>. Optionally takes an
override for the $PATH environment variable.
Always returns a string - an empty one for those
executables that cannot be found.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.filesystem.write_to_path">
<span class="sig-prename descclassname"><span class="pre">clu.fs.filesystem.</span></span><span class="sig-name descname"><span class="pre">write_to_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.filesystem.write_to_path" title="Permalink to this definition"></a></dt>
<dd><p>Write data to a new file using a context-managed handle</p>
</dd></dl>

<span class="target" id="module-clu.fs.misc"></span><dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.current_umask">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">current_umask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.current_umask" title="Permalink to this definition"></a></dt>
<dd><p>Get the current umask value. Results are cached, via “functools.lru_cache(…)”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.differentfile">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">differentfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.differentfile" title="Permalink to this definition"></a></dt>
<dd><p>differentfile(path0, path1) → Return True if path0 and path1 point to different locations on the filesystem</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.differentsize">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">differentsize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.differentsize" title="Permalink to this definition"></a></dt>
<dd><p>Compare the on-disk file sizes (in bytes) of two files by their paths,
returning True if they are different, and False otherwise</p>
<p>“FilesystemError” will be raised if either of the paths are invalid</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.extension">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">extension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dotted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.extension" title="Permalink to this definition"></a></dt>
<dd><p>Return the extension – the file suffix – from a file pathname.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.filesize">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">filesize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.filesize" title="Permalink to this definition"></a></dt>
<dd><p>Return the on-disk size (in bytes) of the file located at a path</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.gethomedir">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">gethomedir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.gethomedir" title="Permalink to this definition"></a></dt>
<dd><p>gethomedir() → Return the current user’s home directory</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.isinvalidpath">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">isinvalidpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.isinvalidpath" title="Permalink to this definition"></a></dt>
<dd><p>isinvalidpath(thing) → boolean predicate, True if <cite>thing</cite> does not represent a valid path on the filesystem</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.masked_chmod">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">masked_chmod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">438</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.masked_chmod" title="Permalink to this definition"></a></dt>
<dd><p>Perform the <cite>os.chmod(…)</cite> operation, respecting the current
umask value (q.v. <cite>current_umask()</cite> supra.)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.masked_permissions">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">masked_permissions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">perms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">438</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.masked_permissions" title="Permalink to this definition"></a></dt>
<dd><p>Compute the permission bitfield, using the current umask value
and a given permission octal number.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.modeflags">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">modeflags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.modeflags" title="Permalink to this definition"></a></dt>
<dd><p>Convert a file-open modestring to an integer flag.</p>
<p>Helper function, used by “clu.fs.filesystem.TemporaryNamedFile(…)”
and “clu.fs.filesystem.NamedTemporaryFile(…)” functions internally.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.octalize">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">octalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">integer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.octalize" title="Permalink to this definition"></a></dt>
<dd><p>octalize(integer) → Format an integer value as an octal number</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.re_excluder">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">re_excluder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">excludes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.re_excluder" title="Permalink to this definition"></a></dt>
<dd><p>Return a boolean function that will search for any of the given
strings (provided as variadic arguments) and return False whenever
any of them are found – True otherwise.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.re_matcher">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">re_matcher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.re_matcher" title="Permalink to this definition"></a></dt>
<dd><p>Return a boolean function that will search for the given
regular-expression within any strings with which it is called,
returning True when the regex matches from the beginning of the
string, and False when it doesn’t.</p>
<p>Results are cached, via “functools.lru_cache(…)”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.re_searcher">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">re_searcher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.re_searcher" title="Permalink to this definition"></a></dt>
<dd><p>Return a boolean function that will search for the given
regular-expression within any strings with which it is called,
returning True when the regex matches and False when it doesn’t.</p>
<p>Results are cached, via “functools.lru_cache(…)”</p>
<p>Useful in filter(…) calls and comprehensions, e.g.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plists</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">re_searcher</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.plist$&#39;</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mmsuffix</span> <span class="o">=</span> <span class="n">suffix_searcher</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.mm$&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">objcpp</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">()</span> <span class="n">where</span> <span class="n">mmsuffix</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.re_suffix">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">re_suffix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.re_suffix" title="Permalink to this definition"></a></dt>
<dd><p>Remove any “os.extsep” prefixing a string, and ensure that
it ends with a “$” – to indicate a regular expression suffix.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.samesize">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">samesize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.samesize" title="Permalink to this definition"></a></dt>
<dd><p>Compare the on-disk file sizes (in bytes) of two files by their paths,
returning True if they are the same, and False otherwise</p>
<p>“FilesystemError” will be raised if either of the paths are invalid</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.suffix_searcher">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">suffix_searcher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.suffix_searcher" title="Permalink to this definition"></a></dt>
<dd><p>Return a boolean function that will search for the given
string within any strings with which it is called, returning
True when they are found and False when they aren’t.</p>
<p>Useful in filter(…) calls and comprehensions, e.g.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plists</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">suffix_searcher</span><span class="p">(</span><span class="s1">&#39;plist&#39;</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mmsuffix</span> <span class="o">=</span> <span class="n">suffix_searcher</span><span class="p">(</span><span class="s1">&#39;mm&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">objcpp</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">()</span> <span class="n">where</span> <span class="n">mmsuffix</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.swapext">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">swapext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_extension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.swapext" title="Permalink to this definition"></a></dt>
<dd><p>Swap the file extension of the path with a newly specified one –
if no extension is present, the newly specified extension will be
amended to the path; the new extension can provide or omit its
leading extension-separator (or a “period” in most human usage).</p>
<p>Like E.G.:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">swapext</span><span class="p">(</span><span class="s1">&#39;/yo/dogg.obj&#39;</span><span class="p">,</span> <span class="s1">&#39;odb&#39;</span><span class="p">)</span>
<span class="go">&#39;/yo/dogg.odb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">swapext</span><span class="p">(</span><span class="s1">&#39;/yo/dogg.obj&#39;</span><span class="p">,</span> <span class="s1">&#39;.odb&#39;</span><span class="p">)</span>
<span class="go">&#39;/yo/dogg.odb&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">swapext</span><span class="p">(</span><span class="s1">&#39;/yo/dogg&#39;</span><span class="p">,</span> <span class="s1">&#39;odb&#39;</span><span class="p">)</span>
<span class="go">&#39;/yo/dogg.odb&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.temporary">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">temporary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.temporary" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper around <cite>tempfile.mktemp()</cite> that allows full overriding of the
prefix and suffix by the caller – that is to say, no random elements
are used in the returned filename if both a prefix and a suffix are
supplied.</p>
<p>To avoid problems, the function will throw a FilesystemError if it is
called with arguments that result in the computation of a filename
that already exists.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.u8bytes">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">u8bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.u8bytes" title="Permalink to this definition"></a></dt>
<dd><p>Encode a source as bytes using the UTF-8 codec, guaranteeing
a proper return value without raising an error</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.u8encode">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">u8encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.u8encode" title="Permalink to this definition"></a></dt>
<dd><p>Encode a source as bytes using the UTF-8 codec</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.u8str">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">u8str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.u8str" title="Permalink to this definition"></a></dt>
<dd><p>Encode a source as a Python string, guaranteeing a proper return
value without raising an error</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.misc.win32_longpath">
<span class="sig-prename descclassname"><span class="pre">clu.fs.misc.</span></span><span class="sig-name descname"><span class="pre">win32_longpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.misc.win32_longpath" title="Permalink to this definition"></a></dt>
<dd><p>Helper function to add the long path prefix for Windows, so that shutil.copytree
won’t fail while working with paths with 255+ chars.</p>
<p>Vendored in from pytest-datadir – q.v. <a class="reference external" href="https://git.io/fjMWl">https://git.io/fjMWl</a> supra.</p>
</dd></dl>

<span class="target" id="module-clu.fs.pypath"></span><dl class="py function">
<dt class="sig sig-object py" id="clu.fs.pypath.add_paths">
<span class="sig-prename descclassname"><span class="pre">clu.fs.pypath.</span></span><span class="sig-name descname"><span class="pre">add_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">putatives</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prepend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.pypath.add_paths" title="Permalink to this definition"></a></dt>
<dd><p>Mutate <cite>sys.path</cite> by adding one or more new paths – all of which
are checked for both nonexistence and presence within the existing
<cite>sys.path</cite> list via inode lookup, and which those failing such checks
are summarily excluded.</p>
<p>Paths are added to <cite>sys.path</cite> by appending, unless “add_paths(…)”
is called with the keyword arg ‘prepend=True’.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.pypath.enhance">
<span class="sig-prename descclassname"><span class="pre">clu.fs.pypath.</span></span><span class="sig-name descname"><span class="pre">enhance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">putatives</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.pypath.enhance" title="Permalink to this definition"></a></dt>
<dd><p>Convenience function for calling “remove_invalid_paths(…)”
before calling “add_paths(•putatives)”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.pypath.remove_invalid_paths">
<span class="sig-prename descclassname"><span class="pre">clu.fs.pypath.</span></span><span class="sig-name descname"><span class="pre">remove_invalid_paths</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.pypath.remove_invalid_paths" title="Permalink to this definition"></a></dt>
<dd><p>Mutate <cite>sys.path</cite> by removing any existing paths that don’t
actually lead to a valid place somewhere on the filesystem
(according to “os.path.exists(…)”). Path removal, as with
“remove_paths(…)”, is done atomically.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.fs.pypath.remove_paths">
<span class="sig-prename descclassname"><span class="pre">clu.fs.pypath.</span></span><span class="sig-name descname"><span class="pre">remove_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">putatives</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.pypath.remove_paths" title="Permalink to this definition"></a></dt>
<dd><p>Mutate <cite>sys.path</cite> by removing one or more existing paths –
all of which are checked for presence within the existing <cite>sys.path</cite>
list via inode lookup before being marked for removal, which that
(the removal) is done atomically.</p>
</dd></dl>

<span class="target" id="module-clu.fs.sourcetree"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.fs.sourcetree.SourceTree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.fs.sourcetree.</span></span><span class="sig-name descname"><span class="pre">SourceTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.fs.sourcetree.SourceTree" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-clu.importing.base">
<span id="clu-importing"></span><h1>clu.importing<a class="headerlink" href="#module-clu.importing.base" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.importing.base.ArgumentSink">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">ArgumentSink</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.ArgumentSink" title="Permalink to this definition"></a></dt>
<dd><p>ArgumentSink is a class that stores the arguments with
which it is initialized, for either later retrieval or
subsequent functional application.</p>
<p>To wit:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sink</span> <span class="o">=</span> <span class="n">ArgumentSink</span><span class="p">(</span><span class="s1">&#39;yo&#39;</span><span class="p">,</span> <span class="s1">&#39;dogg&#39;</span><span class="p">,</span> <span class="n">iheard</span><span class="o">=</span><span class="s2">&quot;you like&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">sink</span><span class="o">.</span><span class="n">args</span> <span class="o">==</span> <span class="p">(</span><span class="s1">&#39;yo&#39;</span><span class="p">,</span> <span class="s1">&#39;dogg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">sink</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">(</span><span class="n">iheard</span><span class="o">=</span><span class="s2">&quot;you like&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sink</span><span class="p">(</span><span class="n">stringify</span><span class="p">)</span> <span class="c1"># prints “str(iheard=you like) @ 0x10bd”</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="clu.importing.base.ArgumentSink.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.ArgumentSink.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.importing.base.FinderBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">FinderBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.FinderBase" title="Permalink to this definition"></a></dt>
<dd><p>The base class for all class-based module finders.</p>
<p>One must subclass this class once per app, specifying
an “appname” – the name of the app. Q.v. the function
“initialize_types(…)” sub. to easily set these up for
your own app.</p>
<p>The class method “FinderBase.find_spec(…)” caches its
returned instances of “ModuleSpec” using a ‘zict.LRU’
buffer, which is shared across all of the installed
“FinderBase” subclasses – meaning that if a spec has
been cached for one installed app via this mechanism,
it will be found by the first Finder subclass that
shows up in “sys.meta_path” to field a query for it (!)</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.importing.base.FinderBase.find_spec">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.FinderBase.find_spec" title="Permalink to this definition"></a></dt>
<dd><p>Return a ModuleSpec for a qualified module name –
creating an instance anew if necessary, and returning
an existing one from the cache if available.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.importing.base.FinderBase.invalidate_caches">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.FinderBase.invalidate_caches" title="Permalink to this definition"></a></dt>
<dd><p>Clear both the Finder’s internal ModuleSpec instance
cache, and its associated Loader instances’ memoization
cache for the “create_module(…)” method (q.v. method
implementation sub.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.importing.base.FinderBase.iter_modules">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iter_modules</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.FinderBase.iter_modules" title="Permalink to this definition"></a></dt>
<dd><p>This “non-standard API method”§ yields ‘pkgutil.ModuleInfo’
instances for each registered class-module in the finder
subclasses’ given app.</p>
<dl class="simple">
<dt>§ q.v. boxed notation sub., Python documentation,</dt><dd><p><a class="reference external" href="https://docs.python.org/3/library/pkgutil.html#pkgutil.iter_modules">https://docs.python.org/3/library/pkgutil.html#pkgutil.iter_modules</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.importing.base.FinderBase.spec">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.FinderBase.spec" title="Permalink to this definition"></a></dt>
<dd><p>Create, cache, and return a new ModuleSpec, corresponding
to a given dotpath (née “fullname”) and using the Finder’s
embedded loader instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.importing.base.LoaderBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">LoaderBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.LoaderBase" title="Permalink to this definition"></a></dt>
<dd><p>The base class for all class-based module loaders.</p>
<p>One must subclass this class once per app, specifying
an “appname” – the name of the app. Q.v. the function
“initialize_types(…)” sub. to easily set these up for
your own app.</p>
<p>The method “LoaderBase.create_module(…)” caches returned
instances of “types.Module” using the ‘functools.lru_cache’
function decorator.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.importing.base.LoaderBase.create_module">
<span class="sig-name descname"><span class="pre">create_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.LoaderBase.create_module" title="Permalink to this definition"></a></dt>
<dd><p>Create a new class-based module from a spec instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.importing.base.LoaderBase.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.LoaderBase.exec_module" title="Permalink to this definition"></a></dt>
<dd><p>Execute a newly created module.</p>
<p>Since the code of class-based module has, by definition,
already been executed by the Python interpreter at this point,
we delegate this action to a user-provided “__execute__()”
instance method of the class-based module in question.</p>
<p>The “__execute__()” method will be called with no arguments.
The class-based module instance will, at this point, have its
“appname” and “appspace” class attributes set and readable,
in addition to all of the contemporary module-instance attributes
documented in e.g. PEP 451 and friends.</p>
<p>An “__execute__()” method shouldn’t return anything.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.importing.base.LoaderBase.package_module">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">package_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.LoaderBase.package_module" title="Permalink to this definition"></a></dt>
<dd><p>Convenience method, returning an empty package module.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.importing.base.ModuleAlias">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">ModuleAlias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">origin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">specializer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.ModuleAlias" title="Permalink to this definition"></a></dt>
<dd><p>A ModuleAlias is created when subscripting the ModuleBase
type, or a subtype thereof, with another ModuleBase subtype,
as per the definition of ProxyModule – q.v. sub. and
“typing” code sample supra.:</p>
<blockquote>
<div><p><a class="reference external" href="https://www.python.org/dev/peps/pep-0560/#mro-entries">https://www.python.org/dev/peps/pep-0560/#mro-entries</a></p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="clu.importing.base.ModuleAlias.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.ModuleAlias.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.importing.base.ModuleBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">ModuleBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.ModuleBase" title="Permalink to this definition"></a></dt>
<dd><p>The base class for all class-based modules.</p>
<p>One must subclass this class once per app, specifying
an “appname” – the name of the app – and an “appspace” –
an optional prefix from which all class-based modules
will be found and imported. Q.v. “initialize_types(…)”
sub. to easily set these up for your own app.</p>
<p>Within CLU, the appname is “clu” (duh) and the appspace
is “app” – all class-based modules are therefore imported
from “clu.app”, á la:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">clu.app</span> <span class="kn">import</span> <span class="n">class_based_module</span>
</pre></div>
</div>
<p>Note that class-based modules are forbidden from using
the “__slots__” class attribute – the module class’ metaclass
will remove any __slots__ it encounters, in fact, so don’t
even bother with ’em.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.importing.base.ModuleSpec">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">ModuleSpec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.ModuleSpec" title="Permalink to this definition"></a></dt>
<dd><p>A local “importlib.machinery.ModuleSpec” subclass
that conveniently deals with setting the “origin”
attribute.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.importing.base.Package">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">Package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.Package" title="Permalink to this definition"></a></dt>
<dd><p>A subclass of ‘types.Module’ which assigns all instances
of which either an empty list or the value of the “path”
keyword argument to its “__path__” attribute in “__init__(…)”</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.importing.base.Registry">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">Registry</span></span><a class="headerlink" href="#clu.importing.base.Registry" title="Permalink to this definition"></a></dt>
<dd><p>The Registry mixin handles the registration of all
class-based module subclasses.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.importing.base.all_registered_appnames">
<span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">all_registered_appnames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.all_registered_appnames" title="Permalink to this definition"></a></dt>
<dd><p>Return a generator of strings listing all registered app names</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.importing.base.all_registered_appspaces">
<span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">all_registered_appspaces</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.all_registered_appspaces" title="Permalink to this definition"></a></dt>
<dd><p>Return a generator of strings listing all registered “appspaces”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.importing.base.all_registered_modules">
<span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">all_registered_modules</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.all_registered_modules" title="Permalink to this definition"></a></dt>
<dd><p>Return a generator over the instances of all registered class-based modules</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.importing.base.appspaces_for_appname">
<span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">appspaces_for_appname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.appspaces_for_appname" title="Permalink to this definition"></a></dt>
<dd><p>Return a generator over the “appspaces” belonging to a given registered app</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.importing.base.get_appspace">
<span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">get_appspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string)</span> <span class="pre">→</span> <span class="pre">Given</span> <span class="pre">a</span> <span class="pre">qualified</span> <span class="pre">name</span> <span class="pre">e.g.</span> <span class="pre">“clu.app.Module”</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extract</span> <span class="pre">the</span> <span class="pre">appspace</span> <span class="pre">(“app”</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">example</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.get_appspace" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.importing.base.initialize_types">
<span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">initialize_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appspace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'app'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.initialize_types" title="Permalink to this definition"></a></dt>
<dd><p>Initialize subtypes of FinderBase, LoaderBase, and ModuleBase,
configured for a specific “appname” and “appspace” (the latter
of which defaults to ‘app’).</p>
<p>You use ‘initialize_types(…)’ in one of your own app’s modules
like so:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Module</span><span class="p">,</span> <span class="n">Finder</span><span class="p">,</span> <span class="n">Loader</span> <span class="o">=</span> <span class="n">initialize_types</span><span class="p">(</span><span class="s1">&#39;myappname&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>… if you insert that line of code in a module of yours called,
say, “myappname/modules.py” you could then either a) proceed
to subclass Module to create your class-modules, or b) import
the ‘Module’ class from elsewhere and subclass it subsequently.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.importing.base.modules_for_appname">
<span class="sig-prename descclassname"><span class="pre">clu.importing.base.</span></span><span class="sig-name descname"><span class="pre">modules_for_appname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">appname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.base.modules_for_appname" title="Permalink to this definition"></a></dt>
<dd><p>Return a generator over the instances of an apps’ registered class-based modules</p>
</dd></dl>

<span class="target" id="module-clu.importing.proxy"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.importing.proxy.ChainModuleMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.importing.proxy.</span></span><span class="sig-name descname"><span class="pre">ChainModuleMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">dicts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fallbacks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">overrides</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.proxy.ChainModuleMap" title="Permalink to this definition"></a></dt>
<dd><p>Custom “clu.dicts.ChainMap” subclass, tailored for module dicts.</p>
<p>In addition to the arguments accepted by its ancestor, one may
pass in a sequence of functions as a keyword argument “fallbacks”.
Each of these functions should accept exactly one argument –
a mapping key string – and either return something for it, or
raise either an AttributeError or a KeyError.</p>
<p>… This is meant to allow one to pass in one or more module-level
“__getattr__(…)” functions, “Mapping.__missing__(…)” methods, or
similar callables – the ChainModuleMap “__missing__(…)” method
itself will attempt to invoke these functions in order, should
it be called upon (hence the name “fallbacks”).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.importing.proxy.ProxyModule">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.importing.proxy.</span></span><span class="sig-name descname"><span class="pre">ProxyModule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">targets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.importing.proxy.ProxyModule" title="Permalink to this definition"></a></dt>
<dd><p>A ProxyModule is a specific type of module: one that wraps one or
more other things and surfaces their attributes, as if they are all
one big unified module.</p>
<p>In this case, “things” can be modules, mappings, or callables – the
ProxyModule employs a bespoke ChainMap subclass to keep these varied
targets in order, for idempotent access with deterministic ordering,
like in a way that ought not surprise or scare anybody.</p>
<p>Callable targets are fallbacks – they are invoked by the “__missing__”
method of the internal ChainMap, when attribute lookup across all of
the module and mapping proxy targets is exhaustively unsuccessful.</p>
<p>The ProxyModule is a “pseudo-template” type – you need to specialize
it with the specific Module types with which you wish to use it.
In nearly every use-case scenario, this means using one of the Module
class types you have obtained through calling “initialize_types(…)”
(as above) – like so:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Module</span><span class="p">,</span> <span class="n">Finder</span><span class="p">,</span> <span class="n">Loader</span> <span class="o">=</span> <span class="n">initialize_types</span><span class="p">(</span><span class="n">my_appname</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">myproxy</span><span class="p">(</span><span class="n">ProxyModule</span><span class="p">[</span><span class="n">Module</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># …etc</span>
</pre></div>
</div>
<p>Here’s a basic example of a ProxyModule subtype definition:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; overrides = dict(…)
&gt;&gt;&gt; from yodogg.app import base_module
&gt;&gt;&gt; from yodogg.utils import misc as second_module
&gt;&gt;&gt; from yodogg.utils.functions import default_factory
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">myproxy</span><span class="p">(</span><span class="n">ProxyModule</span><span class="p">[</span><span class="n">Module</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">targets</span> <span class="o">=</span> <span class="p">(</span><span class="n">overrides</span><span class="p">,</span> <span class="n">base_module</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                        <span class="n">second_module</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                      <span class="n">default_factory</span><span class="p">)</span>
</pre></div>
</div>
<p>… which after defining that, you’d use it like so – assuming your app
is called “yodogg” with a default “app” appspace (see “ModuleBase” for
more on these terms):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">yodogg.app</span> <span class="kn">import</span> <span class="n">myproxy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myproxy</span><span class="o">.</span><span class="n">attrib</span> <span class="c1"># searches overrides, base_module and second_module</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="c1"># in sequence, looking for the &#39;attrib&#39; value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">myproxy</span><span class="p">)</span>   <span class="c1"># returns a list of the union of available stuff,</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="c1"># across the proxy modules’ targets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myproxy</span><span class="o">.</span><span class="n">NOATTR</span> <span class="c1"># unknown attributes will be forwarded to each</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="c1"># module-level “__getattr__(…)” function, dictionary</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="c1"># “__missing__(…)” method, or callable target found,</span>
<span class="gp">&gt;&gt;&gt; </span>               <span class="c1"># in turn, if the attribute search proves exhaustive</span>
</pre></div>
</div>
<p>… you can, in the modules’ definition, include other stuff besides the
class-level “targets” tuple; other elements added to the proxy will
behave like elements of any other class-based module.</p>
</dd></dl>

</section>
<section id="module-clu.keyvalue">
<span id="clu-keyvalue"></span><h1>clu.keyvalue<a class="headerlink" href="#module-clu.keyvalue" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.keyvalue.</span></span><span class="sig-name descname"><span class="pre">CLUInterface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.as_dict">
<span class="sig-name descname"><span class="pre">as_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.as_dict" title="Permalink to this definition"></a></dt>
<dd><p>Return a plain dict with the key-value stores’ contents.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.close" title="Permalink to this definition"></a></dt>
<dd><p>Attept to close zicts</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.count" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of items in this key-value store.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.delete">
<span class="sig-name descname"><span class="pre">delete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.delete" title="Permalink to this definition"></a></dt>
<dd><p>Delete a value from this key-value store.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.get" title="Permalink to this definition"></a></dt>
<dd><p>Return a value from this key-value store.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.has">
<span class="sig-name descname"><span class="pre">has</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.has" title="Permalink to this definition"></a></dt>
<dd><p>Test if a key is contained in this key-value store.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.items" title="Permalink to this definition"></a></dt>
<dd><p>Return an iterable yielding (key, value) for all items in this key-value store.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.iterate">
<span class="sig-name descname"><span class="pre">iterate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.iterate" title="Permalink to this definition"></a></dt>
<dd><p>Return an iterator for this key-value store.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.keys" title="Permalink to this definition"></a></dt>
<dd><p>Return an iterable with all of the keys in this key-value store.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.set" title="Permalink to this definition"></a></dt>
<dd><p>Set and return a value in this key-value store.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.to_string">
<span class="sig-name descname"><span class="pre">to_string</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.to_string" title="Permalink to this definition"></a></dt>
<dd><p>Stringify the CLUInterface instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictish=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**updates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the key-value store with key/value pairs and/or an iterator;
q.v. <cite>dict.update(…)</cite> docstring supra.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.keyvalue.CLUInterface.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.CLUInterface.values" title="Permalink to this definition"></a></dt>
<dd><p>Return an iterable with all of the values in this key-value store.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.keyvalue.count">
<span class="sig-prename descclassname"><span class="pre">clu.keyvalue.</span></span><span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.count" title="Permalink to this definition"></a></dt>
<dd><p>Return the number of items in the key-value store.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.keyvalue.delete">
<span class="sig-prename descclassname"><span class="pre">clu.keyvalue.</span></span><span class="sig-name descname"><span class="pre">delete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.delete" title="Permalink to this definition"></a></dt>
<dd><p>Delete a value from the CLU user-config key-value store.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.keyvalue.get">
<span class="sig-prename descclassname"><span class="pre">clu.keyvalue.</span></span><span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.get" title="Permalink to this definition"></a></dt>
<dd><p>Return a value from the CLU user-config key-value store.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.keyvalue.has">
<span class="sig-prename descclassname"><span class="pre">clu.keyvalue.</span></span><span class="sig-name descname"><span class="pre">has</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.has" title="Permalink to this definition"></a></dt>
<dd><p>Test if a key is contained in the key-value store.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.keyvalue.items">
<span class="sig-prename descclassname"><span class="pre">clu.keyvalue.</span></span><span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.items" title="Permalink to this definition"></a></dt>
<dd><p>Return an iterable yielding (key, value) for all items in the key-value store.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.keyvalue.iterate">
<span class="sig-prename descclassname"><span class="pre">clu.keyvalue.</span></span><span class="sig-name descname"><span class="pre">iterate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.iterate" title="Permalink to this definition"></a></dt>
<dd><p>Return an iterator for the key-value store.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.keyvalue.keys">
<span class="sig-prename descclassname"><span class="pre">clu.keyvalue.</span></span><span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.keys" title="Permalink to this definition"></a></dt>
<dd><p>Return an iterable with all of the keys in the key-value store.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.keyvalue.set">
<span class="sig-prename descclassname"><span class="pre">clu.keyvalue.</span></span><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.set" title="Permalink to this definition"></a></dt>
<dd><p>Set and return a value in the CLU user-config key-value store.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.keyvalue.update">
<span class="sig-prename descclassname"><span class="pre">clu.keyvalue.</span></span><span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictish=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**updates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the CLU key-value store with key/value pairs, and/or an iterator</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.keyvalue.values">
<span class="sig-prename descclassname"><span class="pre">clu.keyvalue.</span></span><span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.keyvalue.values" title="Permalink to this definition"></a></dt>
<dd><p>Return an iterable with all of the values in the key-value store.</p>
</dd></dl>

</section>
<section id="module-clu.mathematics">
<span id="clu-mathematics"></span><h1>clu.mathematics<a class="headerlink" href="#module-clu.mathematics" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.mathematics.Clamper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.mathematics.</span></span><span class="sig-name descname"><span class="pre">Clamper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.mathematics.Clamper" title="Permalink to this definition"></a></dt>
<dd><p>A callable object representing a per-dtype clamp function</p>
<dl class="py property">
<dt class="sig sig-object py" id="clu.mathematics.Clamper.bits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bits</span></span><a class="headerlink" href="#clu.mathematics.Clamper.bits" title="Permalink to this definition"></a></dt>
<dd><p>A human-readable string showing the bitlength of the dtype</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="clu.mathematics.Clamper.kind">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kind</span></span><a class="headerlink" href="#clu.mathematics.Clamper.kind" title="Permalink to this definition"></a></dt>
<dd><p>A human-readable string describing the “kind” of the dtype</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.mathematics.isdtype">
<span class="sig-prename descclassname"><span class="pre">clu.mathematics.</span></span><span class="sig-name descname"><span class="pre">isdtype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.mathematics.isdtype" title="Permalink to this definition"></a></dt>
<dd><p>isdtype(thing) → boolean predicate, True if thing is a non-object numpy dtype</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.mathematics.isnumpything">
<span class="sig-prename descclassname"><span class="pre">clu.mathematics.</span></span><span class="sig-name descname"><span class="pre">isnumpything</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.mathematics.isnumpything" title="Permalink to this definition"></a></dt>
<dd><p>isnumpything(thing) → boolean predicate, True if thing’s qualified module name starts with “numpy”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.mathematics.isnumpythinglist">
<span class="sig-prename descclassname"><span class="pre">clu.mathematics.</span></span><span class="sig-name descname"><span class="pre">isnumpythinglist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thinglist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.mathematics.isnumpythinglist" title="Permalink to this definition"></a></dt>
<dd><p>isnumpythinglist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of things from the “numpy” module</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.mathematics.isnumpytype">
<span class="sig-prename descclassname"><span class="pre">clu.mathematics.</span></span><span class="sig-name descname"><span class="pre">isnumpytype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.mathematics.isnumpytype" title="Permalink to this definition"></a></dt>
<dd><p>isnumpytype(cls) → boolean predicate, True if thing is from the “numpy” module and is a classtype</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.mathematics.isnumpytypelist">
<span class="sig-prename descclassname"><span class="pre">clu.mathematics.</span></span><span class="sig-name descname"><span class="pre">isnumpytypelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thinglist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.mathematics.isnumpytypelist" title="Permalink to this definition"></a></dt>
<dd><p>isnumpytypelist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of types from the “numpy” module</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.mathematics.">
<span class="sig-prename descclassname"><span class="pre">clu.mathematics.</span></span><span class="sig-name descname"><span class="pre">Σ</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.mathematics." title="Permalink to this definition"></a></dt>
<dd><p>reduce(function, sequence[, initial]) -&gt; value</p>
<p>Apply a function of two arguments cumulatively to the items of a sequence,
from left to right, so as to reduce the sequence to a single value.
For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
of the sequence in the calculation, and serves as a default when the
sequence is empty.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id12">
<span class="sig-prename descclassname"><span class="pre">clu.mathematics.</span></span><span class="sig-name descname"><span class="pre">σ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id12" title="Permalink to this definition"></a></dt>
<dd><p>Return the sum of a ‘start’ value (default: 0) plus an iterable of numbers</p>
<p>When the iterable is empty, return the start value.
This function is intended specifically for use with numeric values and may
reject non-numeric types.</p>
</dd></dl>

</section>
<section id="module-clu.naming">
<span id="clu-naming"></span><h1>clu.naming<a class="headerlink" href="#module-clu.naming" title="Permalink to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.determine_module">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">determine_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.determine_module" title="Permalink to this definition"></a></dt>
<dd><p>Private module function to find the module of a thing,
using “pickle.whichmodule(…)”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.dotpath_join">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">dotpath_join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">addenda</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.dotpath_join" title="Permalink to this definition"></a></dt>
<dd><p>Join dotpath elements together as one, á la os.path.join(…)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.dotpath_split">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">dotpath_split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dotpath</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.dotpath_split" title="Permalink to this definition"></a></dt>
<dd><p>For a dotted path e.g. <cite>yo.dogg.DoggListener</cite>,
return a tuple <cite>(‘DoggListener’, ‘yo.dogg’)</cite>.
When called with a string containing no dots,
<cite>dotpath_split(…)</cite> returns <cite>(string, None)</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.dotpath_to_prefix">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">dotpath_to_prefix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dotpath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.dotpath_to_prefix" title="Permalink to this definition"></a></dt>
<dd><p>Convert a dotted path into a “prefix” string, suitable for
use with e.g. clu.fs.filesystem.TemporaryDirectory –
e.g. ‘clu.typespace.namespace.SimpleNamespace’ becomes:</p>
<blockquote>
<div><p>‘clu-typespace-namespace-simplenamespace-’</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.duplicate">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">duplicate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attributes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.duplicate" title="Permalink to this definition"></a></dt>
<dd><p>Make a renamed copy of a target function.</p>
<dl class="simple">
<dt>Q.v. pypy/rpython source supra:</dt><dd><p><a class="reference external" href="http://bit.ly/func-with-new-name">http://bit.ly/func-with-new-name</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.isbuiltin">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">isbuiltin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.isbuiltin" title="Permalink to this definition"></a></dt>
<dd><p>isbuiltin(thing) → boolean predicate, True if <cite>thing</cite> is a builtin function/method/class</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.isinspectable">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">isinspectable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.isinspectable" title="Permalink to this definition"></a></dt>
<dd><p>isinspectable(thing) → boolean predicate, True
if <cite>thing</cite> is inspectable, through the “inspect”
modules’ myriad functions and types.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.isnative">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">isnative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.isnative" title="Permalink to this definition"></a></dt>
<dd><p>isnative(thing) → boolean predicate, True if <cite>thing</cite>
comes from a native-compiled (“extension”) module.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.isnativemodule">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">isnativemodule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.isnativemodule" title="Permalink to this definition"></a></dt>
<dd><p>isnativemodule(thing) → boolean predicate, True if <cite>module</cite>
is a native-compiled (“extension”) module.</p>
<dl class="simple">
<dt>Q.v. this fine StackOverflow answer on this subject:</dt><dd><p><a class="reference external" href="https://stackoverflow.com/a/39304199/298171">https://stackoverflow.com/a/39304199/298171</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.moduleof">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">moduleof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.moduleof" title="Permalink to this definition"></a></dt>
<dd><p>Determine in which module a given thing is ensconced,
and return that modules’ name as a string
… optionally specifying a “default” fallback.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.nameof">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">nameof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.nameof" title="Permalink to this definition"></a></dt>
<dd><p>Get the name of a thing, according to its attributes,
how it appears as a registered item in any Exporter
subclasses, or (failing any of those) as it appears
in the module in which it appears to be ensconced –
… optionally specifying a “default” fallback.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.path_to_prefix">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">path_to_prefix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">PosixPath('/Users/fish/Dropbox/CLU/develop/lib/python3.9/site-packages')</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.path_to_prefix" title="Permalink to this definition"></a></dt>
<dd><p>Shortcut for dotpath_to_prefix(path_to_dotpath(…))</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.qualified_import">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">qualified_import</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qualified</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.qualified_import" title="Permalink to this definition"></a></dt>
<dd><p>Import a qualified thing-name.
e.g. ‘instakit.processors.halftone.FloydSteinberg’</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.qualified_name">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">qualified_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.qualified_name" title="Permalink to this definition"></a></dt>
<dd><p>Get a qualified thing-name for a thing.
e.g. ‘instakit.processors.halftone.FloydSteinberg’</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.qualified_name_tuple">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">qualified_name_tuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.qualified_name_tuple" title="Permalink to this definition"></a></dt>
<dd><p>Get the thing-name and module/package name for a class or module.
e.g. (‘FloydSteinberg’, ‘instakit.processors.halftone’)</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.naming.rename">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">rename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">named</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dotpath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.rename" title="Permalink to this definition"></a></dt>
<dd><p>Function-rename decorator. Use like so:</p>
<blockquote>
<div><p>&#64;rename(named=’yodogg’)
def YoDogg(<a href="#id13"><span class="problematic" id="id14">*</span></a>args):</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
</div></blockquote>
<p>… or:</p>
<blockquote>
<div><p>yodogg = lambda <a href="#id15"><span class="problematic" id="id16">*</span></a>args: …
yodogg = rename()(yodogg) # awkward syntax, I know</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="clu.naming.rename.assign_name">
<span class="sig-name descname"><span class="pre">assign_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.rename.assign_name" title="Permalink to this definition"></a></dt>
<dd><p>Assign the function’s new name. Returns the mutated function.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.renamer">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">renamer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attributes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.renamer" title="Permalink to this definition"></a></dt>
<dd><p>A decorator which renames the target function. Usage:</p>
<blockquote>
<div><p>&#64;renamer(‘yo_dogg’)
def no_dogg():</p>
<blockquote>
<div><p># …</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>Q.v. pypy/rpython source supra:</dt><dd><p><a class="reference external" href="http://bit.ly/func-with-new-name">http://bit.ly/func-with-new-name</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.split_abbreviations">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">split_abbreviations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.split_abbreviations" title="Permalink to this definition"></a></dt>
<dd><p>Split a string into a tuple of its unique constituents,
based on its internal capitalization – to wit:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">split_abbreviations</span><span class="p">(</span><span class="s1">&#39;RGB&#39;</span><span class="p">)</span>
<span class="go">(&#39;R&#39;, &#39;G&#39;, &#39;B&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_abbreviations</span><span class="p">(</span><span class="s1">&#39;CMYK&#39;</span><span class="p">)</span>
<span class="go">(&#39;C&#39;, &#39;M&#39;, &#39;Y&#39;, &#39;K&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_abbreviations</span><span class="p">(</span><span class="s1">&#39;YCbCr&#39;</span><span class="p">)</span>
<span class="go">(&#39;Y&#39;, &#39;Cb&#39;, &#39;Cr&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_abbreviations</span><span class="p">(</span><span class="s1">&#39;sRGB&#39;</span><span class="p">)</span>
<span class="go">(&#39;R&#39;, &#39;G&#39;, &#39;B&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_abbreviations</span><span class="p">(</span><span class="s1">&#39;XYZZ&#39;</span><span class="p">)</span>
<span class="go">(&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_abbreviations</span><span class="p">(</span><span class="s1">&#39;I;16B&#39;</span><span class="p">)</span>
<span class="go">(&#39;I&#39;,)</span>
</pre></div>
</div>
<p>If you still find this function inscrutable,
have a look here: <a class="reference external" href="https://gist.github.com/4027079">https://gist.github.com/4027079</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.naming.suffix">
<span class="sig-prename descclassname"><span class="pre">clu.naming.</span></span><span class="sig-name descname"><span class="pre">suffix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.naming.suffix" title="Permalink to this definition"></a></dt>
<dd><p>suffix(path) → return the suffix ≠ the file extension ≠ for a file pathname</p>
</dd></dl>

</section>
<section id="module-clu.predicates">
<span id="clu-predicates"></span><h1>clu.predicates<a class="headerlink" href="#module-clu.predicates" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.predicates.Base">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">Base</span></span><a class="headerlink" href="#clu.predicates.Base" title="Permalink to this definition"></a></dt>
<dd><p>Base type for programmatically created new types.</p>
<p>Can be accessed as an attribute of “newtype(…)”, e.g. “newtype.Base”;
q.v. the “newtype(…)” function sub.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.accessor">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">accessor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.accessor" title="Permalink to this definition"></a></dt>
<dd><p>accessor(func, thing, <a href="#id17"><span class="problematic" id="id18">*</span></a>attributes) → return the first non-None value had by successively applying func(thing, attribute) to all attributes</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.acquirer">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">acquirer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.acquirer" title="Permalink to this definition"></a></dt>
<dd><p>acquirer(func, thing, <a href="#id19"><span class="problematic" id="id20">*</span></a>attributes) → return all of the non-None values had by successively applying func(thing, attribute) to all attributes</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.allattrs">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">allattrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.allattrs" title="Permalink to this definition"></a></dt>
<dd><p>allattrs(thing, <a href="#id21"><span class="problematic" id="id22">*</span></a>attributes) → boolean predicate, shortcut for <cite>all(hasattr(thing, atx) for atx in attributes)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.allitems">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">allitems</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.allitems" title="Permalink to this definition"></a></dt>
<dd><p>allitems(thing, <a href="#id23"><span class="problematic" id="id24">*</span></a>items) → boolean predicate, shortcut for <cite>all(hasitem(thing, itx) for itx in items)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.allof">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">allof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.allof" title="Permalink to this definition"></a></dt>
<dd><p>allof(<a href="#id25"><span class="problematic" id="id26">*</span></a>items) → Return the result of “all(…)” on all non-<cite>None</cite> arguments</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.allpyattrs">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">allpyattrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.allpyattrs" title="Permalink to this definition"></a></dt>
<dd><p>allpyattrs(thing, <a href="#id27"><span class="problematic" id="id28">*</span></a>attributes) → boolean predicate, shortcut for <cite>all(haspyattr(thing, atx) for atx in attributes)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.always">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">always</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.always" title="Permalink to this definition"></a></dt>
<dd><p>always(thing) → boolean predicate that always returns <cite>True</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.ancestral">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">ancestral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.ancestral" title="Permalink to this definition"></a></dt>
<dd><p>ancestral(atx, cls[, default]) → shortcut for “attr_across(atx, <a href="#id29"><span class="problematic" id="id30">*</span></a>rmro(cls)[, default])”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.ancestral_union">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">ancestral_union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.ancestral_union" title="Permalink to this definition"></a></dt>
<dd><p>ancestral_union(atx, cls[, default]) → shortcut for “uniquify(iterchain(attr_across(atx, <a href="#id31"><span class="problematic" id="id32">*</span></a>mro(cls)[, default])))”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.anyattrs">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">anyattrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.anyattrs" title="Permalink to this definition"></a></dt>
<dd><p>anyattrs(thing, <a href="#id33"><span class="problematic" id="id34">*</span></a>attributes) → boolean predicate, shortcut for <cite>any(hasattr(thing, atx) for atx in attributes)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.anyitems">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">anyitems</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.anyitems" title="Permalink to this definition"></a></dt>
<dd><p>anyitems(thing, <a href="#id35"><span class="problematic" id="id36">*</span></a>items) → boolean predicate, shortcut for <cite>any(hasitem(thing, itx) for itx in items)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.anyof">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">anyof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.anyof" title="Permalink to this definition"></a></dt>
<dd><p>anyof(<a href="#id37"><span class="problematic" id="id38">*</span></a>items) → Return the result of “any(…)” on all non-<cite>None</cite> arguments</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.anypyattrs">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">anypyattrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.anypyattrs" title="Permalink to this definition"></a></dt>
<dd><p>anypyattrs(thing, <a href="#id39"><span class="problematic" id="id40">*</span></a>attributes) → boolean predicate, shortcut for <cite>any(haspyattr(thing, atx) for atx in attributes)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.apply_to">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">apply_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.apply_to" title="Permalink to this definition"></a></dt>
<dd><p>apply_to(predicate, function, <a href="#id41"><span class="problematic" id="id42">*</span></a>things) → Apply a predicate to each
of the things, and finally a function to the entirety of the things,
returning as that function returns. Like e.g.:</p>
<blockquote>
<div><p>function(predicate(thing) for thing in things)</p>
</div></blockquote>
<p>apply_to(predicate, function) → Return a Partial† function ƒ(<a href="#id43"><span class="problematic" id="id44">*</span></a>things)
that will behave as <cite>apply_to(predicate, function, *things)</cite> when it
is called as above.</p>
<p>† q.v. <cite>functools.partial(…)</cite> standard-library module function supra.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.attr">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">attr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.attr" title="Permalink to this definition"></a></dt>
<dd><p>attr(thing, <a href="#id45"><span class="problematic" id="id46">*</span></a>attributes) → Return the first existing attribute from <cite>thing</cite>, given 1+ attribute names</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.attr_across">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">attr_across</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attribute</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*things)</span> <span class="pre">→</span> <span class="pre">Return</span> <span class="pre">all</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">existing</span> <span class="pre">named</span> <span class="pre">attributes</span> <span class="pre">across</span> <span class="pre">all</span> <span class="pre">things</span> <span class="pre">(given</span> <span class="pre">1+</span> <span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.attr_across" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.attr_search">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">attr_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atx</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.attr_search" title="Permalink to this definition"></a></dt>
<dd><p>attr_search(attribute, <a href="#id47"><span class="problematic" id="id48">*</span></a>things) → Return the first-found existing attribute from a thing, given 1+ things</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.attrs">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">attrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.attrs" title="Permalink to this definition"></a></dt>
<dd><p>attrs(thing, <a href="#id49"><span class="problematic" id="id50">*</span></a>attributes) → Return all of the existing named attributes from <cite>thing</cite>, given 1+ attribute names</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.case_sort">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">case_sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string)</span> <span class="pre">→</span> <span class="pre">Sorting</span> <span class="pre">predicate</span> <span class="pre">to</span> <span class="pre">sort</span> <span class="pre">UPPERCASE</span> <span class="pre">names</span> <span class="pre">first</span> <span class="pre">(spoilers:</span> <span class="pre">it</span> <span class="pre">doesn’t</span> <span class="pre">quite</span> <span class="pre">work</span> <span class="pre">actually</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.case_sort" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.class_has">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">class_has</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute)</span> <span class="pre">→</span> <span class="pre">boolean</span> <span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">`cls`</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">class</span> <span class="pre">type</span> <span class="pre">and</span> <span class="pre">has</span> <span class="pre">“attribute”</span> <span class="pre">(in</span> <span class="pre">either</span> <span class="pre">`__dict__`</span> <span class="pre">or</span> <span class="pre">`__slots__`</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.class_has" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.collator">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">collator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xatx</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.collator" title="Permalink to this definition"></a></dt>
<dd><p>collator(func, attribute, <a href="#id51"><span class="problematic" id="id52">*</span></a>things) → return all of the non-None values had by successively applying func(thing, attribute) across all things</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.dunder_or">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">dunder_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.dunder_or" title="Permalink to this definition"></a></dt>
<dd><p>dunder_or(thing, atx) → Like “getpyattr(…)” only with a default return value of <cite>thing</cite> itself</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.enumchoices">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">enumchoices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.enumchoices" title="Permalink to this definition"></a></dt>
<dd><p>enumchoices(cls) → Return a tuple of strings naming the members of an <cite>Enum</cite> class.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.finditem">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">finditem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">itx</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.finditem" title="Permalink to this definition"></a></dt>
<dd><p>finditem(itx, <a href="#id53"><span class="problematic" id="id54">*</span></a>mappings, default=None) → Return the first mapping that contains “itx”, or “default” if “itx” isn’t found in any of them</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.finditems">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">finditems</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">itx</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.finditems" title="Permalink to this definition"></a></dt>
<dd><p>finditems(itx, <a href="#id55"><span class="problematic" id="id56">*</span></a>mappings, default=tuple()) → Return a tuple of all mappings that contain “itx”, or “default” if “itx” isn’t found in any of them</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.getitem">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">getitem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.getitem" title="Permalink to this definition"></a></dt>
<dd><p>getitem(thing, item[, default]) → shortcut for <cite>thing.get(item[, default])</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.getpyattr">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">getpyattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.getpyattr" title="Permalink to this definition"></a></dt>
<dd><p>getpyattr(thing, attribute[, default]) → shortcut for <cite>getattr(thing, ‘__%s__’ % attribute[, default])</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.hasitem">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">hasitem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.hasitem" title="Permalink to this definition"></a></dt>
<dd><p>hasitem(thing, item) → boolean predicate, shortcut for <cite>item in thing</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.haslength">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">haslength</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.haslength" title="Permalink to this definition"></a></dt>
<dd><p>haslength(thing) → boolean predicate, True if <cite>thing</cite> has a “__len__” attribute</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.haspyattr">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">haspyattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.haspyattr" title="Permalink to this definition"></a></dt>
<dd><p>haspyattr(thing, attribute) → boolean predicate, shortcut for <cite>hasattr(thing, ‘__%s__’ % attribute)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.hoist">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">hoist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.hoist" title="Permalink to this definition"></a></dt>
<dd><p>hoist(thing) → if “thing” isn’t already callable, turn it into a lambda that returns it as a value (using “wrap_value(…)”).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isancestor">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isancestor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancestor=&lt;class</span> <span class="pre">'object'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isancestor" title="Permalink to this definition"></a></dt>
<dd><p>isancestor(thing, ancestor=object) → boolean predicate, True if <cite>ancestor</cite> is found in “mro(thing)”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isclass">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isclass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isclass" title="Permalink to this definition"></a></dt>
<dd><p>isclass(thing) → boolean predicate, True if thing is a class, descending from <cite>object</cite> but not <cite>type</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isclasstype">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isclasstype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isclasstype" title="Permalink to this definition"></a></dt>
<dd><p>isclasstype(thing) → boolean predicate, True if thing is a class type, descending from either <cite>object</cite> or <cite>type</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.iscontainer">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">iscontainer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing)</span> <span class="pre">→</span> <span class="pre">boolean</span> <span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">`thing`</span> <span class="pre">is</span> <span class="pre">iterable</span> <span class="pre">and</span> <span class="pre">not</span> <span class="pre">“normative”</span> <span class="pre">(q.v.</span> <span class="pre">`isnormative(…)`</span> <span class="pre">supra.</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.iscontainer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isdictish">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isdictish</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isdictish" title="Permalink to this definition"></a></dt>
<dd><p>isdictish(thing) → boolean predicate, True if <cite>thing</cite> has both an <cite>__mro__</cite> and a <cite>__dict__</cite> attribute</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isenum">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isenum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isenum" title="Permalink to this definition"></a></dt>
<dd><p>isenum(cls) → boolean predicate, True if cls descends from <cite>Enum</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isexpandable">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isexpandable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isexpandable" title="Permalink to this definition"></a></dt>
<dd><p>isexpandable(thing) → boolean predicate, True if <cite>thing</cite> can be <cite>*expanded</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isiterable">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isiterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isiterable" title="Permalink to this definition"></a></dt>
<dd><p>isiterable(thing) → boolean predicate, True if <cite>thing</cite> can be iterated over</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.ismergeable">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">ismergeable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.ismergeable" title="Permalink to this definition"></a></dt>
<dd><p>ismergeable(thing) → boolean predicate, True if <cite>thing</cite> is a valid operand to <cite>merge(…)</cite> or <cite>merge_as(…)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.ismetaclass">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">ismetaclass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.ismetaclass" title="Permalink to this definition"></a></dt>
<dd><p>ismetaclass(thing) → boolean predicate, True if thing is a metaclass, descending directly from <cite>type</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.ismifflin">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">ismifflin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.ismifflin" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if a _sunder_ name, False otherwise.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isnormative">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isnormative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isnormative" title="Permalink to this definition"></a></dt>
<dd><p>isnormative(thing) → boolean predicate, True if <cite>thing</cite> is a string-like or bytes-like iterable</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isnotnone">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isnotnone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isnotnone" title="Permalink to this definition"></a></dt>
<dd><p>isnotnone(thing) → boolean predicate, return True if “thing” is not None</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isorigin">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isorigin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">originator=&lt;class</span> <span class="pre">'object'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isorigin" title="Permalink to this definition"></a></dt>
<dd><p>isorigin(thing, original=object) → boolean predicate, True if <cite>original</cite> is an ancestor of “origin(thing)”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.ispublic">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">ispublic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.ispublic" title="Permalink to this definition"></a></dt>
<dd><p>ispublic(string) → boolean predicate, True if <cite>string</cite> is neither in __dunder__ or _sunder_ (née “_mifflin_”) form</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.ispyname">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">ispyname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.ispyname" title="Permalink to this definition"></a></dt>
<dd><p>Returns True if a __dunder__ name, False otherwise.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isslotdicty">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isslotdicty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isslotdicty" title="Permalink to this definition"></a></dt>
<dd><p>isslotdicty(thing) → boolean predicate, True if <cite>thing</cite> has <cite>__mro__</cite>, <cite>__slots__</cite>, and <cite>__dict__</cite> attributes</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.isslotted">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">isslotted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.isslotted" title="Permalink to this definition"></a></dt>
<dd><p>isslotted(thing) → boolean predicate, True if <cite>thing</cite> has both an <cite>__mro__</cite> and a <cite>__slots__</cite> attribute</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.item">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">item</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.item" title="Permalink to this definition"></a></dt>
<dd><p>item(thing, <a href="#id57"><span class="problematic" id="id58">*</span></a>itemnames) → Return the first existing item held by <cite>thing</cite>, given 1+ item names</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.item_across">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">item_across</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attribute</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*things)</span> <span class="pre">→</span> <span class="pre">Return</span> <span class="pre">all</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">existing</span> <span class="pre">named</span> <span class="pre">items</span> <span class="pre">held</span> <span class="pre">across</span> <span class="pre">all</span> <span class="pre">things</span> <span class="pre">(given</span> <span class="pre">1+</span> <span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.item_across" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.item_search">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">item_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">itx</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.item_search" title="Permalink to this definition"></a></dt>
<dd><p>item_search(itemname, <a href="#id59"><span class="problematic" id="id60">*</span></a>things) → Return the first-found existing item from a thing, given 1+ things</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.items">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.items" title="Permalink to this definition"></a></dt>
<dd><p>items(thing, <a href="#id61"><span class="problematic" id="id62">*</span></a>itemnames) → Return all of the existing named items held by <cite>thing</cite>, given 1+ item names</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.itervariadic">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">itervariadic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.itervariadic" title="Permalink to this definition"></a></dt>
<dd><p>Wrap a variadic function – one with the signature “function(•args)” –
in logic that allows it to be called with a single-argument iterable
(“function(iterable)”) with the same effect.</p>
<p>Screens out strings, bytes-y, and file-path-ish operands without
iterating or expanding them.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.lambda_repr">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">lambda_repr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'&lt;lambda&gt;'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.lambda_repr" title="Permalink to this definition"></a></dt>
<dd><p>lambda_repr(instance) → Equivalent to the built-in <cite>__repr__(…)</cite> method of a lambda function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.listify">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">listify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.listify" title="Permalink to this definition"></a></dt>
<dd><p>listify(<a href="#id63"><span class="problematic" id="id64">*</span></a>items) → Return a new list containing all non-<cite>None</cite> arguments</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.lowers">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">lowers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.lowers" title="Permalink to this definition"></a></dt>
<dd><p>lowers(string) → Sorting predicate, for sorting lowercase-containing names first – returns the lowercase character count</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.metaclass">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">metaclass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.metaclass" title="Permalink to this definition"></a></dt>
<dd><p>metaclass(thing) → Returns: a) thing, if thing is a metaclass; b) type(thing), if thing is a class; or c) type(type(thing)), for all other instances</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.mro">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">mro</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing)</span> <span class="pre">→</span> <span class="pre">Return</span> <span class="pre">the</span> <span class="pre">method</span> <span class="pre">resolution</span> <span class="pre">order</span> <span class="pre">(née</span> <span class="pre">“MRO”)</span> <span class="pre">tuple</span> <span class="pre">for</span> <span class="pre">thing</span> <span class="pre">(using</span> <span class="pre">“type(thing)”</span> <span class="pre">for</span> <span class="pre">non-classtype</span> <span class="pre">operands</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.mro" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.negate">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">negate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.negate" title="Permalink to this definition"></a></dt>
<dd><p>negate(function) → Negate a boolean function, returning the callable inverse.</p>
<p>### … You use <cite>negate(function)</cite> thusly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; iscat = lambda thing: thing == 😺
&gt;&gt;&gt; isnotcat = lambda thing: negate(iscat)(thing) # &lt;-- SEE??
&gt;&gt;&gt; iscat(😺)
True
&gt;&gt;&gt; isnotcat(🐇)
True
&gt;&gt;&gt; isnotcat(😺)
False
</pre></div>
</div>
<p>### … You’ll find that <cite>negate(function)</cite> works great with builtin and stdlib functions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">uncallable</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">thing</span><span class="p">:</span> <span class="n">negate</span><span class="p">(</span><span class="n">callable</span><span class="p">)(</span><span class="n">thing</span><span class="p">)</span> <span class="c1"># see below!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">differentfile</span> <span class="o">=</span> <span class="n">negate</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">samefile</span><span class="p">)</span> <span class="c1"># I’ll admit to having done this</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">misfnmatch</span> <span class="o">=</span> <span class="n">negate</span><span class="p">(</span><span class="n">shutil</span><span class="o">.</span><span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">)</span> <span class="c1"># There are times when this makes sense</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.never">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">never</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.never" title="Permalink to this definition"></a></dt>
<dd><p>never(thing) → boolean predicate that always returns <cite>False</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.newtype">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">newtype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metaclass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.newtype" title="Permalink to this definition"></a></dt>
<dd><p>→ Shortcut for “type(name, tuple(bases) or (newtype.Base,), dict(attributes))”</p>
<p>q.v. <a class="reference external" href="https://docs.python.org/3/library/types.html#dynamic-type-creation">https://docs.python.org/3/library/types.html#dynamic-type-creation</a> supra.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.no_op">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">no_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.no_op" title="Permalink to this definition"></a></dt>
<dd><p>no_op(thing, attribute[, default]) → shortcut for <cite>(attribute or default)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.noattr">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">noattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.noattr" title="Permalink to this definition"></a></dt>
<dd><p>noattr(thing, attribute) → boolean predicate, shortcut for <cite>(not hasattr(thing, attribute))</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.noattrs">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">noattrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.noattrs" title="Permalink to this definition"></a></dt>
<dd><p>noattrs(thing, <a href="#id65"><span class="problematic" id="id66">*</span></a>attributes) → boolean predicate, shortcut for <cite>(not anypyattrs(*attributes)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.noitem">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">noitem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.noitem" title="Permalink to this definition"></a></dt>
<dd><p>noitem(thing, item) → boolean predicate, shortcut for <cite>(not hasitem(thing, item))</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.noitems">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">noitems</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.noitems" title="Permalink to this definition"></a></dt>
<dd><p>noitems(thing, <a href="#id67"><span class="problematic" id="id68">*</span></a>items) → boolean predicate, shortcut for <cite>(not anyitems(*attributes)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.noneof">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">noneof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.noneof" title="Permalink to this definition"></a></dt>
<dd><p>noneof(<a href="#id69"><span class="problematic" id="id70">*</span></a>items) → Return the result of “not any(…)” on all non-<cite>None</cite> arguments</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.nopyattr">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">nopyattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.nopyattr" title="Permalink to this definition"></a></dt>
<dd><p>nopyattr(thing, attribute) → boolean predicate, shortcut for <cite>(not hasattr(thing, ‘__%s__’ % attribute))</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.nopyattrs">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">nopyattrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.nopyattrs" title="Permalink to this definition"></a></dt>
<dd><p>nopyattrs(thing, <a href="#id71"><span class="problematic" id="id72">*</span></a>attributes) → boolean predicate, shortcut for <cite>(not any(haspyattr(thing, atx) for atx in attributes))</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.nuhuh">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">nuhuh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.nuhuh" title="Permalink to this definition"></a></dt>
<dd><p>nuhuh(thing) → boolean predicate that always returns <cite>None</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.or_none">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">or_none</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.or_none" title="Permalink to this definition"></a></dt>
<dd><p>or_none(thing, attribute) → shortcut for <cite>getattr(thing, attribute, None)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.origin">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.origin" title="Permalink to this definition"></a></dt>
<dd><p>origin(thing) → Return either <cite>typeof(thing).__origin__</cite> or <cite>typeof(thing)</cite> for a given <cite>thing</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.predicate_all">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">predicate_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.predicate_all" title="Permalink to this definition"></a></dt>
<dd><p>predicate_all(predicate, <a href="#id73"><span class="problematic" id="id74">*</span></a>things) → boolean predicate, shortcut for <cite>apply_to(predicate, all, *things)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.predicate_and">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">predicate_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.predicate_and" title="Permalink to this definition"></a></dt>
<dd><p>predicate_and(predicate, a, b) → boolean predicate, shortcut for <cite>apply_to(predicate, all, a, b)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.predicate_any">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">predicate_any</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.predicate_any" title="Permalink to this definition"></a></dt>
<dd><p>predicate_any(predicate, <a href="#id75"><span class="problematic" id="id76">*</span></a>things) → boolean predicate, shortcut for <cite>apply_to(predicate, any, *things)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.predicate_none">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">predicate_none</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.predicate_none" title="Permalink to this definition"></a></dt>
<dd><p>predicate_none(predicate, <a href="#id77"><span class="problematic" id="id78">*</span></a>things) → boolean predicate, shortcut for <cite>apply_to(predicate, negate(any), *things)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.predicate_or">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">predicate_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.predicate_or" title="Permalink to this definition"></a></dt>
<dd><p>predicate_or(predicate, a, b) → boolean predicate, shortcut for <cite>apply_to(predicate, any, a, b)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.predicate_xor">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">predicate_xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.predicate_xor" title="Permalink to this definition"></a></dt>
<dd><p>predicate_xor(predicate, a, b) → boolean predicate, shortcut for <cite>apply_to(predicate, any, a, b) and not apply_to(predicate, all, a, b)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.pyattr">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">pyattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.pyattr" title="Permalink to this definition"></a></dt>
<dd><p>pyattr(thing, <a href="#id79"><span class="problematic" id="id80">*</span></a>attributes) → Return the first existing __special__ attribute from <cite>thing</cite>, given 1+ attribute names</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.pyattr_across">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">pyattr_across</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attribute</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*things)</span> <span class="pre">→</span> <span class="pre">Return</span> <span class="pre">all</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">existing</span> <span class="pre">named</span> <span class="pre">__special__</span> <span class="pre">attributes</span> <span class="pre">across</span> <span class="pre">all</span> <span class="pre">things</span> <span class="pre">(given</span> <span class="pre">1+</span> <span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.pyattr_across" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.pyattr_search">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">pyattr_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atx</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.pyattr_search" title="Permalink to this definition"></a></dt>
<dd><p>pyattr_search(attribute, <a href="#id81"><span class="problematic" id="id82">*</span></a>things) → Return the first-found existing __special__ attribute from a thing, given 1+ things</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.pyattrs">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">pyattrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.pyattrs" title="Permalink to this definition"></a></dt>
<dd><p>pyattrs(thing, <a href="#id83"><span class="problematic" id="id84">*</span></a>attributes) → Return all of the existing named __special__ attributes from <cite>thing</cite>, given 1+ attribute names</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.pymodule">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">pymodule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.pymodule" title="Permalink to this definition"></a></dt>
<dd><p>pymodule(thing) → Return either <cite>__module__</cite> or <cite>__package__</cite> from a given <cite>thing</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.pyname">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">pyname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.pyname" title="Permalink to this definition"></a></dt>
<dd><p>pyname(thing) → Return either <cite>__qualname__</cite> or <cite>__name__</cite> from a given <cite>thing</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.resolve">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">resolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.resolve" title="Permalink to this definition"></a></dt>
<dd><p>resolve(thing, atx) → retrieve and resolve an attribute, following
each dotted segment, back from its host thing.</p>
<dl class="simple">
<dt>Q.v. the standard library “operator” module notes supra.:</dt><dd><p><a class="reference external" href="https://docs.python.org/3/library/operator.html#operator.attrgetter">https://docs.python.org/3/library/operator.html#operator.attrgetter</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.retrieve">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">retrieve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.retrieve" title="Permalink to this definition"></a></dt>
<dd><p>retrieve(thing, item[, default]) → shortcut for <cite>hasitem(thing, itx) and thing or default</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.reverse">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">reverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.reverse" title="Permalink to this definition"></a></dt>
<dd><p>reverse(function) → Reverse an iterating function, returning the reverse of the iterable returned.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.rmro">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">rmro</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing)</span> <span class="pre">→</span> <span class="pre">Return</span> <span class="pre">the</span> <span class="pre">reverse</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">method</span> <span class="pre">resolution</span> <span class="pre">order</span> <span class="pre">(née</span> <span class="pre">“MRO”)</span> <span class="pre">tuple</span> <span class="pre">for</span> <span class="pre">thing</span> <span class="pre">(using</span> <span class="pre">“type(thing)”</span> <span class="pre">for</span> <span class="pre">non-classtype</span> <span class="pre">operands</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.rmro" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.searcher">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">searcher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xatx</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.searcher" title="Permalink to this definition"></a></dt>
<dd><p>searcher(func, attribute, <a href="#id85"><span class="problematic" id="id86">*</span></a>things) → return the first non-None value had by successively applying func(thing, attribute) sequentially to all things</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.slots_for">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">slots_for</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.slots_for" title="Permalink to this definition"></a></dt>
<dd><p>slots_for(cls) → get the summation of the <cite>__slots__</cite> tuples for a class and its ancestors</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.stattr">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">stattr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*attributes)</span> <span class="pre">→</span> <span class="pre">Statically</span> <span class="pre">return</span> <span class="pre">the</span> <span class="pre">first</span> <span class="pre">existing</span> <span class="pre">attribute</span> <span class="pre">from</span> <span class="pre">`thing`</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">given</span> <span class="pre">1+</span> <span class="pre">attribute</span> <span class="pre">names</span> <span class="pre">(q.v.</span> <span class="pre">“inspect.getattr_static(¬)”</span> <span class="pre">supra.</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.stattr" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.stattr_across">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">stattr_across</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attribute</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*things)</span> <span class="pre">→</span> <span class="pre">Statically</span> <span class="pre">return</span> <span class="pre">all</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">existing</span> <span class="pre">named</span> <span class="pre">attributes</span> <span class="pre">across</span> <span class="pre">all</span> <span class="pre">things</span> <span class="pre">(given</span> <span class="pre">1+</span> <span class="pre">things)</span> <span class="pre">(q.v.</span> <span class="pre">“inspect.getattr_static(¬)”</span> <span class="pre">supra.</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.stattr_across" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.stattr_search">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">stattr_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attribute</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*things)</span> <span class="pre">→</span> <span class="pre">Statically</span> <span class="pre">return</span> <span class="pre">the</span> <span class="pre">first-found</span> <span class="pre">existing</span> <span class="pre">attribute</span> <span class="pre">from</span> <span class="pre">a</span> <span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">given</span> <span class="pre">1+</span> <span class="pre">things</span> <span class="pre">(q.v.</span> <span class="pre">“inspect.getattr_static(¬)”</span> <span class="pre">supra.</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.stattr_search" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.stattrs">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">stattrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*attributes)</span> <span class="pre">→</span> <span class="pre">Statically</span> <span class="pre">return</span> <span class="pre">all</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">existing</span> <span class="pre">named</span> <span class="pre">attributes</span> <span class="pre">from</span> <span class="pre">`thing`</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">given</span> <span class="pre">1+</span> <span class="pre">attribute</span> <span class="pre">names</span> <span class="pre">(q.v.</span> <span class="pre">“inspect.getattr_static(¬)”</span> <span class="pre">supra.</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.stattrs" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.stor_none">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">stor_none</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.stor_none" title="Permalink to this definition"></a></dt>
<dd><p>stor_none(thing, attribute) → shortcut for <cite>inspect.getattr_static(thing, attribute, None)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.stresolve">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">stresolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.stresolve" title="Permalink to this definition"></a></dt>
<dd><p>stresolve(thing, atx) → statically retrieve and resolve an attribute,
following each dotted segment, back from its host thing.</p>
<dl class="simple">
<dt>Q.v. the standard library “operator” module notes supra.:</dt><dd><p><a class="reference external" href="https://docs.python.org/3/library/operator.html#operator.attrgetter">https://docs.python.org/3/library/operator.html#operator.attrgetter</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.thing_has">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">thing_has</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute)</span> <span class="pre">→</span> <span class="pre">boolean</span> <span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">`thing`</span> <span class="pre">has</span> <span class="pre">“attribute”</span> <span class="pre">(in</span> <span class="pre">either</span> <span class="pre">`__dict__`</span> <span class="pre">or</span> <span class="pre">`__slots__`</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.thing_has" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.try_items">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">try_items</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">itx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*things</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.try_items" title="Permalink to this definition"></a></dt>
<dd><p>try_items(itx, <a href="#id87"><span class="problematic" id="id88">*</span></a>things[, default]) → attempt to retrieve an item
from each of the things, in sequence – falling back to a default,
or raising a KeyError if no default is specified.</p>
<p>This works like “item_search(itx, <a href="#id89"><span class="problematic" id="id90">*</span></a>things[, default])” – with the
notable exception that, if any of the things are instances of
“collections.defaultdict”, “try_items(…)” will correctly trigger
any “defaultdict” instances’ default factories.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.tuplize">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">tuplize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.tuplize" title="Permalink to this definition"></a></dt>
<dd><p>tuplize(<a href="#id91"><span class="problematic" id="id92">*</span></a>items) → Return a new tuple containing all non-<cite>None</cite> arguments</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.typeof">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">typeof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.typeof" title="Permalink to this definition"></a></dt>
<dd><p>typeof(thing) → Returns thing, if thing is a class type; or type(thing), if it is not</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.uncallable">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">uncallable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.uncallable" title="Permalink to this definition"></a></dt>
<dd><p>uncallable(thing) → boolean predicate, shortcut for <cite>not callable(thing)</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.union">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.union" title="Permalink to this definition"></a></dt>
<dd><p>union(<a href="#id93"><span class="problematic" id="id94">*</span></a>items) → Return the set-union of the contents of all non-<cite>None</cite> arguments</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.uniquify">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">uniquify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">items</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.uniquify" title="Permalink to this definition"></a></dt>
<dd><p>uniquify(<a href="#id95"><span class="problematic" id="id96">*</span></a>items) → Return a generator yielding a unique set of all non-<cite>None</cite> arguments</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.unwrap">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">unwrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.unwrap" title="Permalink to this definition"></a></dt>
<dd><p>unwrap(thing) → Return either <cite>thing.__wrapped__</cite> or <cite>thing</cite> for a given <cite>thing</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.uppers">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">uppers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.uppers" title="Permalink to this definition"></a></dt>
<dd><p>uppers(string) → Sorting predicate, for sorting UPPERCASE-containing names first – returns the UPPERCASE character count</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.predicates.wrap_value">
<span class="sig-prename descclassname"><span class="pre">clu.predicates.</span></span><span class="sig-name descname"><span class="pre">wrap_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.predicates.wrap_value" title="Permalink to this definition"></a></dt>
<dd><p>wrap_value(value) → Get a “lazified” copy of <cite>value</cite>, wrapped in a lamba</p>
</dd></dl>

</section>
<section id="module-clu.repl.ansi">
<span id="clu-repl"></span><h1>clu.repl<a class="headerlink" href="#module-clu.repl.ansi" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSI">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">ANSI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSI" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSI.convert">
<span class="sig-name descname"><span class="pre">convert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">specifier</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSI.convert" title="Permalink to this definition"></a></dt>
<dd><p>Convert a specifier of unknown type to an enum or alias member</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSI.for_name">
<span class="sig-name descname"><span class="pre">for_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSI.for_name" title="Permalink to this definition"></a></dt>
<dd><p>Get an enum member or alias member by name</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">ANSIBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIBase" title="Permalink to this definition"></a></dt>
<dd><p>Root ancestor class for all ANSI-code enums</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSICodeHighlighter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">ANSICodeHighlighter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">language</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'python'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markup</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'terminal256'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'paraiso-dark'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSICodeHighlighter" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSICodeHighlighter.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSICodeHighlighter.render" title="Permalink to this definition"></a></dt>
<dd><p>Render a string with respect to the Format instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">ANSIFormat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Text.NOTHING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Background.NOTHING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Weight.NORMAL</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat" title="Permalink to this definition"></a></dt>
<dd><p>The formatter class for ANSI markup codes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a cloned copy of this instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat.from_dict">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat.from_dict" title="Permalink to this definition"></a></dt>
<dd><p>Instantiate an ANSIFormat with a dict of related ANSI values –
q.v. FIELD string names supra.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat.get_or_create">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_or_create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat.get_or_create" title="Permalink to this definition"></a></dt>
<dd><p>Return an instance matching the given text/background/weight.</p>
<p>Any such instance found in the cache will be summarily returned;
otherwise, a new instance is created and ensconced in the cache
before finally ending up as the return itself.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat.instance_for">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">instance_for</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat.instance_for" title="Permalink to this definition"></a></dt>
<dd><p>Return an instance matching a given text/background/weight from
the instance cache, or – if such an instance can’t be found –
raise a descriptive KeyError to indicate failure</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat.null">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">null</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat.null" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve a “null instance” of ANSIFormat – one with all of its
formatting directives unspecified.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat.pre_existing">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pre_existing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat.pre_existing" title="Permalink to this definition"></a></dt>
<dd><p>Boolean function to test the instance cache for the presence of
an ANSIFormat instance matching a given text/background/weight</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat.render" title="Permalink to this definition"></a></dt>
<dd><p>Render a string appropriately marked up with the ANSI formatting
called for by this ANSIFormat instance, ending with the necessary
ANSI reset sequence(s).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat.to_dict">
<span class="sig-name descname"><span class="pre">to_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat.to_dict" title="Permalink to this definition"></a></dt>
<dd><p>Return the ANSI format primitives as a dict</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat.to_string">
<span class="sig-name descname"><span class="pre">to_string</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat.to_string" title="Permalink to this definition"></a></dt>
<dd><p>Build up an initial ANSI format string based on values present</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormat.to_tuple">
<span class="sig-name descname"><span class="pre">to_tuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormat.to_tuple" title="Permalink to this definition"></a></dt>
<dd><p>Return the ANSI format primitives as a tuple</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormatBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">ANSIFormatBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSIFormatBase" title="Permalink to this definition"></a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormatBase.background">
<span class="sig-name descname"><span class="pre">background</span></span><a class="headerlink" href="#clu.repl.ansi.ANSIFormatBase.background" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormatBase.text">
<span class="sig-name descname"><span class="pre">text</span></span><a class="headerlink" href="#clu.repl.ansi.ANSIFormatBase.text" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSIFormatBase.weight">
<span class="sig-name descname"><span class="pre">weight</span></span><a class="headerlink" href="#clu.repl.ansi.ANSIFormatBase.weight" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.ANSISanitizer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">ANSISanitizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ANSISanitizer" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.Background">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">Background</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.Background" title="Permalink to this definition"></a></dt>
<dd><p>Enumeration mapping ANSI codes to names found in “colorama.ansi.Back”</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.DualOptionWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">DualOptionWrapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kwargs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwalts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.DualOptionWrapper" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.HighlighterWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">HighlighterWrapper</span></span><a class="headerlink" href="#clu.repl.ansi.HighlighterWrapper" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.ParagraphWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">ParagraphWrapper</span></span><a class="headerlink" href="#clu.repl.ansi.ParagraphWrapper" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.ParagraphWrapper.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.ParagraphWrapper.render" title="Permalink to this definition"></a></dt>
<dd><p>Render a string with respect to the Format instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.PygmentsHighlighter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">PygmentsHighlighter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">language</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'python'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markup</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'terminal256'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'paraiso-dark'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.PygmentsHighlighter" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.PygmentsHighlighter.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.PygmentsHighlighter.render" title="Permalink to this definition"></a></dt>
<dd><p>Render a string with respect to the Format instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.StagedFormat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">StagedFormat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.StagedFormat" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.StagedFormat.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.StagedFormat.render" title="Permalink to this definition"></a></dt>
<dd><p>Render a string with respect to the Format instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.Text">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">Text</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.Text" title="Permalink to this definition"></a></dt>
<dd><p>Enumeration mapping ANSI codes to names found in “colorama.ansi.Fore”</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.TextWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">TextWrapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.TextWrapper" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="clu.repl.ansi.TextWrapper.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.TextWrapper.render" title="Permalink to this definition"></a></dt>
<dd><p>Render a string with respect to the Format instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.ansi.Weight">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">Weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.Weight" title="Permalink to this definition"></a></dt>
<dd><p>Enumeration mapping ANSI codes to names found in “colorama.ansi.Style”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.ansi.highlight">
<span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">highlight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">code_string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">language</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'python'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markup</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'terminal256'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'paraiso-dark'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isatty</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.highlight" title="Permalink to this definition"></a></dt>
<dd><p>Highlight a code string with inline 256-color ANSI markup,
using <cite>pygments.highlight(…)</cite> and the “Paraiso Dark” theme</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.ansi.paragraphize">
<span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">paragraphize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">doc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.paragraphize" title="Permalink to this definition"></a></dt>
<dd><p>Split a docstring into continuous paragraphs.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.ansi.print_ansi">
<span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">print_ansi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.print_ansi" title="Permalink to this definition"></a></dt>
<dd><p>print_ansi(…) → Print text in ANSI color, using optional inline markup
from <cite>colorama</cite> for terminal color-escape delimiters</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.ansi.print_ansi_centered">
<span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">print_ansi_centered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filler='•'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file=&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.print_ansi_centered" title="Permalink to this definition"></a></dt>
<dd><p>print_ansi_centered(…) → Print a string to the terminal, centered
and bookended with asterisks</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.ansi.print_ansi_name_value">
<span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">print_ansi_name_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">most=25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pilcrow='\x1b[31m\x1b[22m»\x1b[0m'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equals='\x1b[90m\x1b[22m:\x1b[0m'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color=ANSIFormat(text=NOTHING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background=NOTHING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight=NORMAL)</span> <span class="pre">&#64;</span> <span class="pre">0x1063f7630</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file=&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namecolor=ANSIFormat(text=LIGHTBLUE_EX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background=NOTHING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight=NORMAL)</span> <span class="pre">&#64;</span> <span class="pre">0x1063f72c0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valuecolor=ANSIFormat(text=LIGHTBLACK_EX</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background=NOTHING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight=NORMAL)</span> <span class="pre">&#64;</span> <span class="pre">0x1063f74f0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.print_ansi_name_value" title="Permalink to this definition"></a></dt>
<dd><p>Format and colorize each segment of the name/value output</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.ansi.print_separator">
<span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">print_separator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.print_separator" title="Permalink to this definition"></a></dt>
<dd><p>print_separator(filler=’-’) → print ‘filler’ character consts.SEPARATOR_WIDTH times</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.ansi.signature">
<span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.signature" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve the signature for a thing, parsing the docstring
if necessary.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.ansi.wrapper_kws">
<span class="sig-prename descclassname"><span class="pre">clu.repl.ansi.</span></span><span class="sig-name descname"><span class="pre">wrapper_kws</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.ansi.wrapper_kws" title="Permalink to this definition"></a></dt>
<dd><p>wrapper_kws(<a href="#id97"><span class="problematic" id="id98">**</span></a>kwargs) → prepare default arguments for instancing a “textwrap.TextWrapper”</p>
</dd></dl>

<span class="target" id="module-clu.repl.banners"></span><span class="target" id="module-clu.repl.columnize"></span><p>Transform an iterable list of something into a columnized
string representation.</p>
<p>Adapted from the routine of the same name found in “cmd.py”;
further messed with to remove all the “pass” statements,
simplify keyword-arg handling, normalize basically all of the
argument names, and generally adapt it to the CLU world.</p>
<p>Q.v. the original pre-CLU version supra: <a class="reference external" href="https://git.io/JvPfl">https://git.io/JvPfl</a></p>
<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.columnize.Percenter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.columnize.</span></span><span class="sig-name descname"><span class="pre">Percenter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opstring</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.columnize.Percenter" title="Permalink to this definition"></a></dt>
<dd><p>A format type that uses the %% (string-interpolation) operator
on its opstring to render its operands.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.columnize.Percenter.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.columnize.Percenter.render" title="Permalink to this definition"></a></dt>
<dd><p>Render a string with respect to the Format instance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.columnize.StrMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.columnize.</span></span><span class="sig-name descname"><span class="pre">StrMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opstring</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.columnize.StrMethod" title="Permalink to this definition"></a></dt>
<dd><p>A format type that uses a call to the “format(…)” method
on its opstring to render its operands.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.columnize.StrMethod.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.columnize.StrMethod.render" title="Permalink to this definition"></a></dt>
<dd><p>Render a string with respect to the Format instance.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.columnize.columnize">
<span class="sig-prename descclassname"><span class="pre">clu.repl.columnize.</span></span><span class="sig-name descname"><span class="pre">columnize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">129</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.columnize.columnize" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Return a list of strings as a compact set of columns, distributed</dt><dd><p>horizontally or vertically.</p>
<dl class="simple">
<dt>For example, for a line width of 4 characters (arranged vertically):</dt><dd><p>[‘1’, ‘2,’, ‘3’, ‘4’] → ‘1  3</p>
</dd>
</dl>
</dd>
</dl>
<p>2  4
‘</p>
<blockquote>
<div><dl class="simple">
<dt>… or arranged horizontally:</dt><dd><p>[‘1’, ‘2,’, ‘3’, ‘4’] → ‘1  2</p>
</dd>
</dl>
</div></blockquote>
<p>3  4
‘</p>
<blockquote>
<div><p>Each column is only as wide as necessary.  By default, columns
are separated by two spaces - one wasn’t legible enough.</p>
<ul class="simple">
<li><p>Set the “separator” option to adjust the string separate columns.</p></li>
<li><p>Set “display_width” to set the line width.</p></li>
</ul>
<p>Normally, consecutive items go down from the top to bottom from
the left-most column to the right-most. If “vertical_display” is
set false, consecutive items will go across, left to right, top to
bottom.</p>
</div></blockquote>
</dd></dl>

<span class="target" id="module-clu.repl.modules"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.repl.modules.Mismatch">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.modules.</span></span><span class="sig-name descname"><span class="pre">Mismatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">which</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">determine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thingname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.modules.Mismatch" title="Permalink to this definition"></a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Mismatch.determine">
<span class="sig-name descname"><span class="pre">determine</span></span><a class="headerlink" href="#clu.repl.modules.Mismatch.determine" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Mismatch.idx">
<span class="sig-name descname"><span class="pre">idx</span></span><a class="headerlink" href="#clu.repl.modules.Mismatch.idx" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Mismatch.modulename">
<span class="sig-name descname"><span class="pre">modulename</span></span><a class="headerlink" href="#clu.repl.modules.Mismatch.modulename" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Mismatch.thingname">
<span class="sig-name descname"><span class="pre">thingname</span></span><a class="headerlink" href="#clu.repl.modules.Mismatch.thingname" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Mismatch.which">
<span class="sig-name descname"><span class="pre">which</span></span><a class="headerlink" href="#clu.repl.modules.Mismatch.which" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.modules.Mismatches">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.modules.</span></span><span class="sig-name descname"><span class="pre">Mismatches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">total</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mismatch_records</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">failure_rate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.modules.Mismatches" title="Permalink to this definition"></a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Mismatches.failure_rate">
<span class="sig-name descname"><span class="pre">failure_rate</span></span><a class="headerlink" href="#clu.repl.modules.Mismatches.failure_rate" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Mismatches.mismatch_records">
<span class="sig-name descname"><span class="pre">mismatch_records</span></span><a class="headerlink" href="#clu.repl.modules.Mismatches.mismatch_records" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Mismatches.total">
<span class="sig-name descname"><span class="pre">total</span></span><a class="headerlink" href="#clu.repl.modules.Mismatches.total" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.modules.ModuleMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.modules.</span></span><span class="sig-name descname"><span class="pre">ModuleMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.modules.ModuleMap" title="Permalink to this definition"></a></dt>
<dd><p>An adaptor class, wrapping a module and providing access to
that modules’ non-dunder-named exports through an implementation
of the “collections.abc.Mapping” interface.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.modules.ModuleMap.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.modules.ModuleMap.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a cloned copy of the ModuleMap instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.modules.ModuleMap.inner_repr">
<span class="sig-name descname"><span class="pre">inner_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.modules.ModuleMap.inner_repr" title="Permalink to this definition"></a></dt>
<dd><p>Return a repr string for instances of this class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.modules.ModuleMap.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">a</span> <span class="pre">set-like</span> <span class="pre">object</span> <span class="pre">providing</span> <span class="pre">a</span> <span class="pre">view</span> <span class="pre">on</span> <span class="pre">D's</span> <span class="pre">items</span></span></span><a class="headerlink" href="#clu.repl.modules.ModuleMap.items" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.modules.ModuleMap.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">a</span> <span class="pre">set-like</span> <span class="pre">object</span> <span class="pre">providing</span> <span class="pre">a</span> <span class="pre">view</span> <span class="pre">on</span> <span class="pre">D's</span> <span class="pre">keys</span></span></span><a class="headerlink" href="#clu.repl.modules.ModuleMap.keys" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.modules.ModuleMap.most">
<span class="sig-name descname"><span class="pre">most</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.modules.ModuleMap.most" title="Permalink to this definition"></a></dt>
<dd><p>Return the string-length of the longest item name in the module</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.repl.modules.ModuleMap.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">an</span> <span class="pre">object</span> <span class="pre">providing</span> <span class="pre">a</span> <span class="pre">view</span> <span class="pre">on</span> <span class="pre">D's</span> <span class="pre">values</span></span></span><a class="headerlink" href="#clu.repl.modules.ModuleMap.values" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.modules.Result">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.modules.</span></span><span class="sig-name descname"><span class="pre">Result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">modulename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thingnames</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.modules.Result" title="Permalink to this definition"></a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Result.idx">
<span class="sig-name descname"><span class="pre">idx</span></span><a class="headerlink" href="#clu.repl.modules.Result.idx" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Result.modulename">
<span class="sig-name descname"><span class="pre">modulename</span></span><a class="headerlink" href="#clu.repl.modules.Result.modulename" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Result.thingnames">
<span class="sig-name descname"><span class="pre">thingnames</span></span><a class="headerlink" href="#clu.repl.modules.Result.thingnames" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.repl.modules.Results">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.repl.modules.</span></span><span class="sig-name descname"><span class="pre">Results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">total</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulenames</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result_records</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.modules.Results" title="Permalink to this definition"></a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Results.modulenames">
<span class="sig-name descname"><span class="pre">modulenames</span></span><a class="headerlink" href="#clu.repl.modules.Results.modulenames" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Results.result_records">
<span class="sig-name descname"><span class="pre">result_records</span></span><a class="headerlink" href="#clu.repl.modules.Results.result_records" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.repl.modules.Results.total">
<span class="sig-name descname"><span class="pre">total</span></span><a class="headerlink" href="#clu.repl.modules.Results.total" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.modules.compare_module_lookups_for_all_things">
<span class="sig-prename descclassname"><span class="pre">clu.repl.modules.</span></span><span class="sig-name descname"><span class="pre">compare_module_lookups_for_all_things</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">modules</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.modules.compare_module_lookups_for_all_things" title="Permalink to this definition"></a></dt>
<dd><p>Iterate through each exported item, for each exported module,
and look up the original module of the exported item with both:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>“pickle.whichmodule(…)” and</p></li>
<li><p>“clu.naming.moduleof(…)”</p></li>
</ol>
</div></blockquote>
<p>… comparing the results of the two search functions and computing
the overall results.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.modules.isplural">
<span class="sig-prename descclassname"><span class="pre">clu.repl.modules.</span></span><span class="sig-name descname"><span class="pre">isplural</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">integer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.modules.isplural" title="Permalink to this definition"></a></dt>
<dd><p>isplural(integer) → returns an ‘s’ unless the integer argument is 1, in which case it returns an empty string</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repl.modules.notpyname">
<span class="sig-prename descclassname"><span class="pre">clu.repl.modules.</span></span><span class="sig-name descname"><span class="pre">notpyname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repl.modules.notpyname" title="Permalink to this definition"></a></dt>
<dd><p>notpyname(string) → boolean predicate, returns True unless string is a __dunder__ name, when it returns False</p>
</dd></dl>

</section>
<section id="module-clu.repr">
<span id="clu-repr"></span><h1>clu.repr<a class="headerlink" href="#module-clu.repr" title="Permalink to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="clu.repr.chop_instance_repr">
<span class="sig-prename descclassname"><span class="pre">clu.repr.</span></span><span class="sig-name descname"><span class="pre">chop_instance_repr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repr.chop_instance_repr" title="Permalink to this definition"></a></dt>
<dd><p>Discard the the object-instance hex ID portion of
an instance repr string</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repr.compare_instance_reprs">
<span class="sig-prename descclassname"><span class="pre">clu.repr.</span></span><span class="sig-name descname"><span class="pre">compare_instance_reprs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repr0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">reprX</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repr.compare_instance_reprs" title="Permalink to this definition"></a></dt>
<dd><p>Compare two or more instance reprs after discarding
the object-instance hex ID</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repr.fullrepr">
<span class="sig-prename descclassname"><span class="pre">clu.repr.</span></span><span class="sig-name descname"><span class="pre">fullrepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repr.fullrepr" title="Permalink to this definition"></a></dt>
<dd><p>Return a “full-repr” string for an instance and a given string.</p>
<p>For example, in the case of the following repr-stle string:</p>
<blockquote>
<div><p>TypeName(fieldname=”val”, otherfieldname=”otherval”) &#64; 0x0FE</p>
</div></blockquote>
<p>…the parameter “string” is the portion if the full-repr string
that reads:</p>
<blockquote>
<div><p>“fieldname=”val”, otherfieldname=”otherval””</p>
</div></blockquote>
<p>… whereas the ‘TypeName’ and hex-ID portions are derived from
the “instance” parameter.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repr.hexid">
<span class="sig-prename descclassname"><span class="pre">clu.repr.</span></span><span class="sig-name descname"><span class="pre">hexid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repr.hexid" title="Permalink to this definition"></a></dt>
<dd><p>hexid(thing) → Return the hex-ified representation of “thing”’s ID – Equivalent to “hex(id(thing))”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repr.strfields">
<span class="sig-prename descclassname"><span class="pre">clu.repr.</span></span><span class="sig-name descname"><span class="pre">strfields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">extras</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">try_callables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attributes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repr.strfields" title="Permalink to this definition"></a></dt>
<dd><p>Stringify an object instance, using an iterable field list to
extract and render its values, and printing them along with the 
typename of the instance and its memory address – yielding a
repr-style string of the format:</p>
<blockquote>
<div><p>“fieldname=”val”, otherfieldname=”otherval””</p>
</div></blockquote>
<p>The <cite>strfields(…)</cite> function is of use in <cite>__str__()</cite> and <cite>__repr__()</cite>
definitions, e.g. something like:</p>
<blockquote>
<div><dl class="simple">
<dt>def inner_repr(self):</dt><dd><p>return strfields(self, type(self).__slots__)</p>
</dd>
<dt>def __repr__(self):</dt><dd><p>typename, hex_id = typename_hexid(self)
attr_string = self.inner_repr()
return f”{typename}({attr_string}) {consts.REPR_DELIMITER} {hex_id}”</p>
</dd>
</dl>
</div></blockquote>
<p>Callable fields, by default, will be called with no arguments
to obtain their value. To supress this behavior – if you wish
to represent callable fields that require arguments – you can
pass the keyword-only “try_callables” flag as False:</p>
<blockquote>
<div><dl class="simple">
<dt>def inner_repr(self):</dt><dd><dl class="simple">
<dt>return strfields(self,</dt><dd><p>type(self).__slots__,
try_callables=False)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repr.stringify">
<span class="sig-prename descclassname"><span class="pre">clu.repr.</span></span><span class="sig-name descname"><span class="pre">stringify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">extras</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">try_callables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attributes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repr.stringify" title="Permalink to this definition"></a></dt>
<dd><p>Stringify an object instance, using an iterable field list to
extract and render its values, and printing them along with the 
typename of the instance and its memory address – yielding a
repr-style string of the format:</p>
<blockquote>
<div><p>TypeName(fieldname=”val”, otherfieldname=”otherval”) &#64; 0x0FE</p>
</div></blockquote>
<p>The <cite>stringify(…)</cite> function is of use in <cite>__str__()</cite> and <cite>__repr__()</cite>
definitions, e.g. something like:</p>
<blockquote>
<div><dl class="simple">
<dt>def __repr__(self):</dt><dd><p>return stringify(self, type(self).__slots__)</p>
</dd>
</dl>
</div></blockquote>
<p>Callable fields, by default, will be called with no arguments
to obtain their value. To supress this behavior – if you wish
to represent callable fields that require arguments – you can
pass the keyword-only “try_callables” flag as False:</p>
<blockquote>
<div><dl class="simple">
<dt>def __repr__(self):</dt><dd><dl class="simple">
<dt>return stringify(self,</dt><dd><p>type(self).__slots__,
try_callables=False)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repr.typename_hexid">
<span class="sig-prename descclassname"><span class="pre">clu.repr.</span></span><span class="sig-name descname"><span class="pre">typename_hexid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repr.typename_hexid" title="Permalink to this definition"></a></dt>
<dd><p>typename_hexid(thing) → Return a two-tuple containing “thing”’s hex-ified ID and the string name of the type of “thing” – Equivalent to “(hexid(thing), typenameof(thing))”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.repr.typenameof">
<span class="sig-prename descclassname"><span class="pre">clu.repr.</span></span><span class="sig-name descname"><span class="pre">typenameof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.repr.typenameof" title="Permalink to this definition"></a></dt>
<dd><p>typenameof(thing) → Return the string name of the type of “thing” – Equivalent to “pyname(typeof(thing))”, q.v. “clu.predicates”</p>
</dd></dl>

</section>
<section id="module-clu.sanitizer">
<span id="clu-sanitizer"></span><h1>clu.sanitizer<a class="headerlink" href="#module-clu.sanitizer" title="Permalink to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="clu.sanitizer.sanitize">
<span class="sig-prename descclassname"><span class="pre">clu.sanitizer.</span></span><span class="sig-name descname"><span class="pre">sanitize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.sanitizer.sanitize" title="Permalink to this definition"></a></dt>
<dd><p>sanitize(text) → Remove specific unicode strings, in favor of ASCII-friendly versions,
from the text passed in to the function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.sanitizer.sanitizers">
<span class="sig-prename descclassname"><span class="pre">clu.sanitizer.</span></span><span class="sig-name descname"><span class="pre">sanitizers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.sanitizer.sanitizers" title="Permalink to this definition"></a></dt>
<dd><p>sanitizers() → shortcut to get a tuple of tuples listing the registered sanitizers</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.sanitizer.utf8_decode">
<span class="sig-prename descclassname"><span class="pre">clu.sanitizer.</span></span><span class="sig-name descname"><span class="pre">utf8_decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.sanitizer.utf8_decode" title="Permalink to this definition"></a></dt>
<dd><p>utf8_decode(source) → Decode a source from UTF-8 bytes to a string using Python 3 semantics</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.sanitizer.utf8_encode">
<span class="sig-prename descclassname"><span class="pre">clu.sanitizer.</span></span><span class="sig-name descname"><span class="pre">utf8_encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.sanitizer.utf8_encode" title="Permalink to this definition"></a></dt>
<dd><p>utf8_encode(source) → Encode a source as a UTF-8 bytes object using Python 3 semantics</p>
</dd></dl>

</section>
<section id="module-clu.scripts.ansicolors">
<span id="clu-scripts"></span><h1>clu.scripts<a class="headerlink" href="#module-clu.scripts.ansicolors" title="Permalink to this heading"></a></h1>
<span class="target" id="module-clu.scripts.prediversus"></span><dl class="py function">
<dt class="sig sig-object py" id="clu.scripts.prediversus.predicate_test">
<span class="sig-prename descclassname"><span class="pre">clu.scripts.prediversus.</span></span><span class="sig-name descname"><span class="pre">predicate_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">argument)</span> <span class="pre">→</span> <span class="pre">executes</span> <span class="pre">`predicate(argument)`</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returning</span> <span class="pre">(`predicate`</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">`argument`</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">`predicate(argument)`</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.scripts.prediversus.predicate_test" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.scripts.prediversus.predicate_test_repr">
<span class="sig-prename descclassname"><span class="pre">clu.scripts.prediversus.</span></span><span class="sig-name descname"><span class="pre">predicate_test_repr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">argument)</span> <span class="pre">→</span> <span class="pre">stringifies</span> <span class="pre">`predicate`</span> <span class="pre">and</span> <span class="pre">`argument`</span> <span class="pre">–</span> <span class="pre">both</span> <span class="pre">individually</span> <span class="pre">and</span> <span class="pre">as</span> <span class="pre">the</span> <span class="pre">complete</span> <span class="pre">expression</span> <span class="pre">`predicate(argument)`</span> <span class="pre">–</span> <span class="pre">returning</span> <span class="pre">(«operand</span> <span class="pre">string»</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">«expression</span> <span class="pre">string»</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.scripts.prediversus.predicate_test_repr" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<span class="target" id="module-clu.scripts.repl"></span><p>repl.py – THE RUBRICK:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>Import all modules with an exporter, excluding those from a list</dt><dd><p>… e.g. equivalent to “import clu.exporting”, etc.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Import modules without an exporter, including those from a list</dt><dd><p>… e.g. “clu.constants.consts” and friends</p>
</dd>
</dl>
</li>
<li><p>Export everything from modules from (1) and (2)
into the global namespace</p></li>
<li><p>Import additional modules (whether CLU, stdlib, or third-party)
and just leave the modules themselves hanging out in
the global namespace</p></li>
<li><p>Deal with any nitpicks – e.g. “from pprint import pprint”,
“from clu.testing.utils import pout” and what have you</p></li>
<li><p>PUSH IT REAL GOOD</p></li>
<li><p>LOOK ON MY WORK, YE MIGHTY, AND MAYBE BE LIKE “I COULD USE THAT”</p></li>
</ol>
</section>
<section id="module-clu.shelving">
<span id="clu-shelving"></span><h1>clu.shelving<a class="headerlink" href="#module-clu.shelving" title="Permalink to this heading"></a></h1>
</section>
<section id="module-clu.stdio">
<span id="clu-stdio"></span><h1>clu.stdio<a class="headerlink" href="#module-clu.stdio" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.stdio.TermSize">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.stdio.</span></span><span class="sig-name descname"><span class="pre">TermSize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">&lt;factory&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">&lt;factory&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">&lt;factory&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.stdio.TermSize" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.stdio.flush_all">
<span class="sig-prename descclassname"><span class="pre">clu.stdio.</span></span><span class="sig-name descname"><span class="pre">flush_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.stdio.flush_all" title="Permalink to this definition"></a></dt>
<dd><p>flush_all() → flush the output buffers of all possible <cite>stdout</cite> candidates</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.stdio.linebreak">
<span class="sig-prename descclassname"><span class="pre">clu.stdio.</span></span><span class="sig-name descname"><span class="pre">linebreak</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.stdio.linebreak" title="Permalink to this definition"></a></dt>
<dd><p>linebreak() → print a newline to <cite>stdout</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.stdio.terminal_size">
<span class="sig-prename descclassname"><span class="pre">clu.stdio.</span></span><span class="sig-name descname"><span class="pre">terminal_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.stdio.terminal_size" title="Permalink to this definition"></a></dt>
<dd><p>Deeper cut than “os.get_terminal_size(…)” value in “consts”</p>
</dd></dl>

</section>
<section id="module-clu.testing.pytest">
<span id="clu-testing"></span><h1>clu.testing<a class="headerlink" href="#module-clu.testing.pytest" title="Permalink to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.clumods">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">clumods</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">consts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.clumods" title="Permalink to this definition"></a></dt>
<dd><p>Import all CLU modules that use the “clu.exporting.Exporter”
mechanism for listing and exporting their module contents</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.cluversion">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">cluversion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.cluversion" title="Permalink to this definition"></a></dt>
<dd><p>Fixture providing access to the current base version identifier –
née the “semver” or “semantic version” – of the CLU project</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.consts">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">consts</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.consts" title="Permalink to this definition"></a></dt>
<dd><p>Fixture providing access to the CLU constants module, which
you may know as “clu.constants.consts”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.datadir">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">datadir</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dirname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.datadir" title="Permalink to this definition"></a></dt>
<dd><p>Local version of pytest-datadir’s “datadir” fixture, reimplemented
using clu.fs.filesystem classes – ensuring that the temporary
directory will be deleted immediately after use – and performing
its copy operations through instance methods (vs. the raw calls
to “shutil.copytree(…)” made by “datadir”).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.dirname">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">dirname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.dirname" title="Permalink to this definition"></a></dt>
<dd><p>Fixture for wrapping up the “request.fspath.dirname” value in a
clu.fs.filesystem.Directory instance – this is intended to be a
read-only value (no way to enforce that just now) so we only run
it once per test package (which really there is one test package,
total, so you see what we’re going for here doggie).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.environment">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">environment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.environment" title="Permalink to this definition"></a></dt>
<dd><p>Environment testing fixture: yields an instance of <cite>os.environ</cite>,
free of XDG variables</p>
<p>Q.v. implementation <a class="reference external" href="https://git.io/JeYmf">https://git.io/JeYmf</a> supra.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.gitrun">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">gitrun</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.gitrun" title="Permalink to this definition"></a></dt>
<dd><p>Boolean fixture indicating whether or not this session
is running within a Git repo (vs. like a tarball or somesuch).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.greektext">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">greektext</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.greektext" title="Permalink to this definition"></a></dt>
<dd><p>Greek-text fixture: yield a dictionary with several lorem-ipsum-ish
blocks of text.</p>
<p>Keys to the available texts are:</p>
<blockquote>
<div><ul class="simple">
<li><p>“lorem”   (the classic),</p></li>
<li><p>“faust”   (lots of Germanic short capitalized words),</p></li>
<li><p>“thoreau” (in actual English), and</p></li>
<li><p>“poe”     (exerpted from The Raven, because I live in Baltimore)</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>… All these came straight from the output of the top-notch <cite>lorem</cite> CLT:</dt><dd><p><a class="reference external" href="https://github.com/per9000/lorem">https://github.com/per9000/lorem</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.pytest_addhooks">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">pytest_addhooks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pluginmanager</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.pytest_addhooks" title="Permalink to this definition"></a></dt>
<dd><p>Add all hooks defined in the “clu.testing.hooks” module</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.pytest_addoption">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">pytest_addoption</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parser</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pluginmanager</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.pytest_addoption" title="Permalink to this definition"></a></dt>
<dd><p>Set up the CLI/config option for “–delete-temps”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.pytest_configure">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">pytest_configure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.pytest_configure" title="Permalink to this definition"></a></dt>
<dd><p>Add the pytest custom markers used in CLU’s testing extensions</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.pytest_sessionfinish">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">pytest_sessionfinish</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">session</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exitstatus</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.pytest_sessionfinish" title="Permalink to this definition"></a></dt>
<dd><p>Hook function to bind an exit handle – using “clu.dispatch”
via the ‘&#64;exithandle’ decorator – that removes any remaining
temporary-file artifacts that may be hanging out in the
putative directory “$TMPDIR/pytest-of-$USER”.</p>
<p>The exit handle function is bound if the exit status is “natural” –
i.e. no internal errors and tests ran normally (this can include
occasions when tests fail) – and if the relevant CLI, INI, and hook
function values indicate said binding is warranted by the user.</p>
<p>The exit handle function executes when the Python interpreter
either enters shutdown (via the “atexit” module) or receives
a terminating signal (via the “signal” module).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.temporarydir">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">temporarydir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.temporarydir" title="Permalink to this definition"></a></dt>
<dd><p>clu.fs.filesystem.TemporaryDirectory fixture factory: yields
a new instance of <cite>TemporaryDirectory</cite>, without making any
calls to “os.chdir()”.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.testing.pytest.temporaryname">
<span class="sig-prename descclassname"><span class="pre">clu.testing.pytest.</span></span><span class="sig-name descname"><span class="pre">temporaryname</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.testing.pytest.temporaryname" title="Permalink to this definition"></a></dt>
<dd><p>clu.fs.filesystem.TemporaryName fixture-factory function: yields
a function returning new instances of <cite>TemporaryName</cite>, which
can be called multiple times – each time producing a new
<cite>TemporaryName</cite> instance under automatic context-management
(via a behind-the-scenes “contextlib.ExitStack” instance).</p>
<p>The parent fixture is module-scoped; when the module in which
this fixture-factory function was first invoked enters cleanup,
the ExitStack is unwound and all <cite>TemporaryName</cite> instances are
__exit__(…)-ed at that time.</p>
</dd></dl>

</section>
<section id="module-clu.typespace">
<span id="clu-typespace"></span><h1>clu.typespace<a class="headerlink" href="#module-clu.typespace" title="Permalink to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="clu.typespace.modulize">
<span class="sig-prename descclassname"><span class="pre">clu.typespace.</span></span><span class="sig-name descname"><span class="pre">modulize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">docs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">appname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'clu'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basepath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">PosixPath('/Users/fish/Dropbox/CLU/develop/lib/python3.9/site-packages')</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.modulize" title="Permalink to this definition"></a></dt>
<dd><p>Convert a dictionary mapping into a legit Python module</p>
</dd></dl>

<span class="target" id="module-clu.typespace.namespace"></span><dl class="py class">
<dt class="sig sig-object py" id="clu.typespace.namespace.BaseNamespace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.typespace.namespace.</span></span><span class="sig-name descname"><span class="pre">BaseNamespace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.BaseNamespace" title="Permalink to this definition"></a></dt>
<dd><p>The abstract base for SimpleNamespace and Namespace.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.typespace.namespace.BaseNamespace.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.BaseNamespace.clone" title="Permalink to this definition"></a></dt>
<dd><p>Return a cloned copy of this instance</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.typespace.namespace.Namespace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.typespace.namespace.</span></span><span class="sig-name descname"><span class="pre">Namespace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.Namespace" title="Permalink to this definition"></a></dt>
<dd><p>Namespace adds the <cite>get(…)</cite>, <cite>__len__()</cite>, <cite>__contains__(…)</cite>, <cite>__getitem__(…)</cite>,
<cite>__setitem__(…)</cite>, and <cite>__add__(…)</cite> methods to its ancestor class
implementation BaseNamespace.</p>
<p>Since it implements a <cite>get(…)</cite> method, Namespace instances can be passed
to <cite>merge(…)</cite> – q.v. <cite>merge(…)</cite> function definition supra.</p>
<p>The Namespace class also furnishes a <cite>__missing__(…)</cite> method, which can
be overridden by subclasses to provide “collections.defaultdict”–like
behaviors.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.typespace.namespace.Namespace.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.Namespace.get" title="Permalink to this definition"></a></dt>
<dd><p>Return the value for key if key is in the namespace, else default.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.typespace.namespace.Namespace.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;class</span> <span class="pre">'clu.constants.consts.NoDefault'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.Namespace.pop" title="Permalink to this definition"></a></dt>
<dd><p>Return the value for key if key is in the namespace, else default,
removing the key/value pairing if the key was found.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.typespace.namespace.Namespace.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictish</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">updates</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.Namespace.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the namespace with key/value pairs and/or an iterator;
q.v. <cite>dict.update(…)</cite> docstring supra.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.typespace.namespace.NamespaceRepr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.typespace.namespace.</span></span><span class="sig-name descname"><span class="pre">NamespaceRepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxlevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxstring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">120</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxother</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">120</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.NamespaceRepr" title="Permalink to this definition"></a></dt>
<dd><p>Custom Repr-izer for SimpleNamespace and Namespace
mappings, which can recursively self-contain.</p>
<p>q.v. cpython docs, <a class="reference external" href="http://bit.ly/2r1GQ4l">http://bit.ly/2r1GQ4l</a> supra.</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.typespace.namespace.NamespaceRepr.fullrepr">
<span class="sig-name descname"><span class="pre">fullrepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">short</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.NamespaceRepr.fullrepr" title="Permalink to this definition"></a></dt>
<dd><p>Return the “full” repr of a namespace instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.typespace.namespace.NamespaceRepr.primerepr">
<span class="sig-name descname"><span class="pre">primerepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.NamespaceRepr.primerepr" title="Permalink to this definition"></a></dt>
<dd><p>The internal method for “core” repr production
of all namespace descendant types.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.typespace.namespace.NamespaceRepr.repr_BaseNamespace">
<span class="sig-name descname"><span class="pre">repr_BaseNamespace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.NamespaceRepr.repr_BaseNamespace" title="Permalink to this definition"></a></dt>
<dd><p>Return the “core” repr for a specific instance of
“clu.typespace.namespace.BaseNamespace” – just the
stringification of the key-value pairs, without
the typename or instance-id adornment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.typespace.namespace.NamespaceRepr.repr_Namespace">
<span class="sig-name descname"><span class="pre">repr_Namespace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.NamespaceRepr.repr_Namespace" title="Permalink to this definition"></a></dt>
<dd><p>Return the “core” repr for a specific instance of
“clu.typespace.namespace.Namespace” – just the
stringification of the key-value pairs, without
the typename or instance-id adornment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.typespace.namespace.NamespaceRepr.repr_SimpleNamespace">
<span class="sig-name descname"><span class="pre">repr_SimpleNamespace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.NamespaceRepr.repr_SimpleNamespace" title="Permalink to this definition"></a></dt>
<dd><p>Return the “core” repr for a specific instance of
“clu.typespace.namespace.SimpleNamespace” – just
the stringification of the key-value pairs, without
the typename or instance-id adornment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.typespace.namespace.NamespaceRepr.shortrepr">
<span class="sig-name descname"><span class="pre">shortrepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.NamespaceRepr.shortrepr" title="Permalink to this definition"></a></dt>
<dd><p>Return the “short” repr of a namespace instance –
all whitespace will be condensed to single spaces
without newlines.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.typespace.namespace.NamespaceRepr.subrepr">
<span class="sig-name descname"><span class="pre">subrepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.NamespaceRepr.subrepr" title="Permalink to this definition"></a></dt>
<dd><p>An internal “core” repr helper method.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.typespace.namespace.SimpleNamespace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.typespace.namespace.</span></span><span class="sig-name descname"><span class="pre">SimpleNamespace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.SimpleNamespace" title="Permalink to this definition"></a></dt>
<dd><p>Implementation courtesy this SO answer:
• <a class="reference external" href="https://stackoverflow.com/a/37161391/298171">https://stackoverflow.com/a/37161391/298171</a></p>
<p>Additionally, SimpleNamespace furnishes an <cite>__hash__(…)</cite> method.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typespace.namespace.isnamespace">
<span class="sig-prename descclassname"><span class="pre">clu.typespace.namespace.</span></span><span class="sig-name descname"><span class="pre">isnamespace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.isnamespace" title="Permalink to this definition"></a></dt>
<dd><p>isnamespace(thing) → boolean predicate,
True if the name of the type of “thing”
is amongst those of the quote-unquote
“Namespace tower”, as defined in the
module “clu.typespace.namespace”</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typespace.namespace.nsrepr">
<span class="sig-prename descclassname"><span class="pre">clu.typespace.namespace.</span></span><span class="sig-name descname"><span class="pre">nsrepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.nsrepr" title="Permalink to this definition"></a></dt>
<dd><p>Return the “core” repr for any descendant ChainMap type.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typespace.namespace.nsshortrepr">
<span class="sig-prename descclassname"><span class="pre">clu.typespace.namespace.</span></span><span class="sig-name descname"><span class="pre">nsshortrepr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typespace.namespace.nsshortrepr" title="Permalink to this definition"></a></dt>
<dd><p>Return the “short” repr of a namespace instance –
all whitespace will be condensed to single spaces
without newlines.</p>
</dd></dl>

</section>
<section id="module-clu.typology">
<span id="clu-typology"></span><h1>clu.typology<a class="headerlink" href="#module-clu.typology" title="Permalink to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.differentlength">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">differentlength</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.differentlength" title="Permalink to this definition"></a></dt>
<dd><p>differentlength(a, b) → boolean predicate, True if both <cite>len(a)</cite> and <cite>len(b)</cite> are defined, but are unequal</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.graceful_issubclass">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">graceful_issubclass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">putative</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">thinglist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.graceful_issubclass" title="Permalink to this definition"></a></dt>
<dd><p>subclasscheck(putative, <a href="#id99"><span class="problematic" id="id100">*</span></a>cls_or_tuple) → A wrapper for <cite>issubclass(…)</cite> and <cite>isinstance(…)</cite> that tries to work with you</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.hasaliases">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">hasaliases</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.hasaliases" title="Permalink to this definition"></a></dt>
<dd><p>hasaliases(cls) → boolean predicate, True if <cite>cls</cite> descends from Enum and has 1+ items in its <cite>__aliases__</cite> dict</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.hasmembers">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">hasmembers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.hasmembers" title="Permalink to this definition"></a></dt>
<dd><p>hasmembers(cls) → boolean predicate, True if <cite>cls</cite> descends from Enum and has 1+ items in its <cite>__members__</cite> dict</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isabc">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isabc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isabc" title="Permalink to this definition"></a></dt>
<dd><p>isabc(thing) → boolean predicate, True if <cite>thing</cite> is an abstract base class (née ‘ABC’) or a descendant or instance of same</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isabclist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isabclist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thinglist)</span> <span class="pre">→</span> <span class="pre">boolean</span> <span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">`thinglist`</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">sequence</span> <span class="pre">of</span> <span class="pre">abstract</span> <span class="pre">base</span> <span class="pre">classes</span> <span class="pre">(née</span> <span class="pre">ABCs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isabclist" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isabstract">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isabstract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing)</span> <span class="pre">→</span> <span class="pre">boolean</span> <span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">`thing`</span> <span class="pre">is</span> <span class="pre">an</span> <span class="pre">abstract</span> <span class="pre">method</span> <span class="pre">OR</span> <span class="pre">an</span> <span class="pre">“abstract</span> <span class="pre">base</span> <span class="pre">class”</span> <span class="pre">(née</span> <span class="pre">ABC</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isabstract" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isabstractcontextmanager">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isabstractcontextmanager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isabstractcontextmanager" title="Permalink to this definition"></a></dt>
<dd><p>isabstractcontextmanager(thing) → boolean predicate, True if <cite>thing</cite> decends from <cite>contextlib.AbstractContextManager</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isabstractmethod">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isabstractmethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isabstractmethod" title="Permalink to this definition"></a></dt>
<dd><p>isabstractmethod(thing) → boolean predicate, True if <cite>thing</cite> is a method declared “abstract” with <cite>&#64;abc.abstractmethod</cite></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isaliasdescriptor">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isaliasdescriptor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isaliasdescriptor" title="Permalink to this definition"></a></dt>
<dd><p>isaliasdescriptor(thing) → boolean predicate, returns True if <cite>thing</cite> is an aliasing descriptor bound to an existing Enum member</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isarray">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isarray" title="Permalink to this definition"></a></dt>
<dd><p>isarray(thing) → boolean predicate, True if <cite>thing</cite> is an array type or an instance of same</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isarraylist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isarraylist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isarraylist" title="Permalink to this definition"></a></dt>
<dd><p>isarraylist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of array types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isbytes">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isbytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isbytes" title="Permalink to this definition"></a></dt>
<dd><p>isbytes(thing) → boolean predicate, True if <cite>thing</cite> is a bytes-like type or an instance of same</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isbyteslist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isbyteslist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isbyteslist" title="Permalink to this definition"></a></dt>
<dd><p>isbyteslist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of bytes-like types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.iscallable">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">iscallable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.iscallable" title="Permalink to this definition"></a></dt>
<dd><p>iscallable(thing) → boolean predicate, True if <cite>thing</cite> is a callable type (a class with a “__call__” method) or an instance of same</p>
<p>N.B. this predicate is <em>NOT</em> the same as the built-in “callable(…)” predicate</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.iscallablelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">iscallablelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thinglist)</span> <span class="pre">→</span> <span class="pre">boolean</span> <span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">`thinglist`</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">sequence</span> <span class="pre">of</span> <span class="pre">callable</span> <span class="pre">types</span> <span class="pre">(class</span> <span class="pre">types</span> <span class="pre">with</span> <span class="pre">“__call__”</span> <span class="pre">methods</span> <span class="pre">or</span> <span class="pre">instances</span> <span class="pre">of</span> <span class="pre">same</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.iscallablelist" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.iscallabletype">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">iscallabletype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing)</span> <span class="pre">→</span> <span class="pre">boolean</span> <span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">`thing`</span> <span class="pre">is</span> <span class="pre">one</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">predefined</span> <span class="pre">callable</span> <span class="pre">types</span> <span class="pre">(q.v.</span> <span class="pre">“clu.typology.callable_types”</span> <span class="pre">supra.</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.iscallabletype" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.iscallabletypelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">iscallabletypelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thinglist)</span> <span class="pre">→</span> <span class="pre">boolean</span> <span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">`thinglist`</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">sequence</span> <span class="pre">of</span> <span class="pre">predefined</span> <span class="pre">callable</span> <span class="pre">types</span> <span class="pre">(q.v.</span> <span class="pre">“clu.typology.callable_types”</span> <span class="pre">supra.</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.iscallabletypelist" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.iscomplex">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">iscomplex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.iscomplex" title="Permalink to this definition"></a></dt>
<dd><p>iscomplex(thing) → boolean predicate, True if <cite>thing</cite> is a complex numeric type or an instance of same</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.iscomplexlist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">iscomplexlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.iscomplexlist" title="Permalink to this definition"></a></dt>
<dd><p>iscomplexlist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of complex numeric types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.iscontextmanager">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">iscontextmanager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing)</span> <span class="pre">→</span> <span class="pre">boolean</span> <span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">`thing`</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">context</span> <span class="pre">manager</span> <span class="pre">(either</span> <span class="pre">abstract</span> <span class="pre">or</span> <span class="pre">concrete</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.iscontextmanager" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isderivative">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isderivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">putative</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isderivative" title="Permalink to this definition"></a></dt>
<dd><p>isderivative(putative, thing) → Boolean predicate, True if putative is either
a subclass or an instance of thing – depending on whether putative is either
a classtype or an instance, basically.</p>
<p>Used internally to implement <cite>subclasscheck(…)</cite> (née “graceful_issubclass(…)”).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isextensibletype">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isextensibletype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing)</span> <span class="pre">→</span> <span class="pre">boolean</span> <span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">`thing`</span> <span class="pre">is</span> <span class="pre">an</span> <span class="pre">“extensible”</span> <span class="pre">type</span> <span class="pre">(q.v.</span> <span class="pre">“clu.extending”</span> <span class="pre">source</span> <span class="pre">supra.</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isextensibletype" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isfunction">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isfunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isfunction" title="Permalink to this definition"></a></dt>
<dd><p>ΛΛ(thing) → boolean predicate, True if <cite>thing</cite> is of a callable function type</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isfunctionlist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isfunctionlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isfunctionlist" title="Permalink to this definition"></a></dt>
<dd><p>isfunctionlist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of callable function types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.ishashable">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ishashable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.ishashable" title="Permalink to this definition"></a></dt>
<dd><p>ishashable(thing) → boolean predicate, True if <cite>thing</cite> can be hashed, via the builtin <cite>hash(…)</cite> function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.ishashablelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ishashablelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.ishashablelist" title="Permalink to this definition"></a></dt>
<dd><p>ishashablelist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of things that can be hashed, via the builtin <cite>hash(…)</cite> function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isitemsview">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isitemsview</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isitemsview" title="Permalink to this definition"></a></dt>
<dd><p>isitemsview(thing) → boolean predicate, True if <cite>thing</cite> is a mapping-items view instance</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.iskeysview">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">iskeysview</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.iskeysview" title="Permalink to this definition"></a></dt>
<dd><p>iskeysview(thing) → boolean predicate, True if <cite>thing</cite> is a mapping-keys view instance</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.islambda">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">islambda</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.islambda" title="Permalink to this definition"></a></dt>
<dd><p>λλ(thing) → boolean predicate, True if <cite>thing</cite> is a function created with the «lambda» keyword</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.islambdalist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">islambdalist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.islambdalist" title="Permalink to this definition"></a></dt>
<dd><p>islambdalist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of functions created with the «lambda» keyword</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.ismapping">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ismapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.ismapping" title="Permalink to this definition"></a></dt>
<dd><p>ismapping(thing) → boolean predicate, True if <cite>thing</cite> is a mapping (dict-ish) type or an instance of same</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.ismappinglist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ismappinglist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.ismappinglist" title="Permalink to this definition"></a></dt>
<dd><p>ismappinglist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of mapping (dict-ish) types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.ismetatypelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ismetatypelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.ismetatypelist" title="Permalink to this definition"></a></dt>
<dd><p>ismetatypelist(thing) → boolean predicate, True if <cite>thing</cite> is a “metatypelist” – a list consisting only of metaclass types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.ismodule">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ismodule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.ismodule" title="Permalink to this definition"></a></dt>
<dd><p>ismodule(thing) → boolean predicate, True if <cite>thing</cite> is a module type or an instance of same</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.ismodulelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ismodulelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.ismodulelist" title="Permalink to this definition"></a></dt>
<dd><p>ismodulelist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of module types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isnotpath">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isnotpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isnotpath" title="Permalink to this definition"></a></dt>
<dd><p>isnotpath(thing) → boolean predicate, True if <cite>thing</cite> seems not to be a path-ish instance</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isnumber">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isnumber</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isnumber" title="Permalink to this definition"></a></dt>
<dd><p>isnumber(thing) → boolean predicate, True if <cite>thing</cite> is a numeric type or an instance of same</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isnumberlist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isnumberlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isnumberlist" title="Permalink to this definition"></a></dt>
<dd><p>isnumberlist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of numeric types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isnumeric">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isnumeric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isnumeric" title="Permalink to this definition"></a></dt>
<dd><p>isnumeric(thing) → boolean predicate, True if <cite>thing</cite> is a numeric type or an instance of same</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isnumericlist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isnumericlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isnumericlist" title="Permalink to this definition"></a></dt>
<dd><p>isnumericlist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of numeric types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.ispath">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ispath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.ispath" title="Permalink to this definition"></a></dt>
<dd><p>ispath(thing) → boolean predicate, True if <cite>thing</cite> seems to be a path-ish instance</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.ispathlist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ispathlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.ispathlist" title="Permalink to this definition"></a></dt>
<dd><p>ispathlist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of path-like instances</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.ispathtype">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ispathtype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.ispathtype" title="Permalink to this definition"></a></dt>
<dd><p>ispathtype(thing) → boolean predicate, True if <cite>thing</cite> is a path type</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.ispathtypelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ispathtypelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.ispathtypelist" title="Permalink to this definition"></a></dt>
<dd><p>ispathtypelist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of path-related class types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isscalar">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isscalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isscalar" title="Permalink to this definition"></a></dt>
<dd><p>isscalar(thing) → boolean predicate, True if <cite>thing</cite> is a numpy scalar numeric type or an instance of same</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isscalarlist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isscalarlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isscalarlist" title="Permalink to this definition"></a></dt>
<dd><p>isscalarlist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of numpy scalar numeric types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.issequence">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">issequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing)</span> <span class="pre">→</span> <span class="pre">boolean</span> <span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">`thing`</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">sequence</span> <span class="pre">type</span> <span class="pre">(e.g.</span> <span class="pre">a</span> <span class="pre">`tuple`</span> <span class="pre">or</span> <span class="pre">`list`</span> <span class="pre">type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.issequence" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.issequencelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">issequencelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.issequencelist" title="Permalink to this definition"></a></dt>
<dd><p>issequencelist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of sequence types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.issingleton">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">issingleton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.issingleton" title="Permalink to this definition"></a></dt>
<dd><p>issingleton(thing) → boolean predicate, True if <cite>thing</cite> is one of the “singleton” types: True, False, None, Ellipsis (aka “…”) or NotImplemented</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.issingletonlist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">issingletonlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.issingletonlist" title="Permalink to this definition"></a></dt>
<dd><p>issingletonlist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of things that are amongst the “singleton” types: True, False, None, Ellipsis (aka “…”) or NotImplemented</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isslottedtype">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isslottedtype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isslottedtype" title="Permalink to this definition"></a></dt>
<dd><p>isslottedtype(thing) → boolean predicate, True if <cite>thing</cite> has “clu.exporting.Slotted” as its metaclass</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isstring">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isstring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isstring" title="Permalink to this definition"></a></dt>
<dd><p>isstring(thing) → boolean predicate, True if <cite>thing</cite> is a string type or an instance of same</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isstringlist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isstringlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isstringlist" title="Permalink to this definition"></a></dt>
<dd><p>isstringlist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of string types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.istypelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">istypelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.istypelist" title="Permalink to this definition"></a></dt>
<dd><p>istypelist(thing) → boolean predicate, True if <cite>thing</cite> is a “typelist” – a list consisting only of class types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isunique">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isunique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isunique" title="Permalink to this definition"></a></dt>
<dd><p>isunique(thing) → boolean predicate, True if <cite>thing</cite> is an iterable with unique contents</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isvalidpath">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isvalidpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isvalidpath" title="Permalink to this definition"></a></dt>
<dd><p>isvalidpath(thing) → boolean predicate, True if <cite>thing</cite> represents a valid path on the filesystem</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isvalidpathlist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isvalidpathlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isvalidpathlist" title="Permalink to this definition"></a></dt>
<dd><p>isvalidpathlist(thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of valid filesystem path instances</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isvaluesview">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isvaluesview</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isvaluesview" title="Permalink to this definition"></a></dt>
<dd><p>isvaluesview(thing) → boolean predicate, True if <cite>thing</cite> is a mapping-values view instance</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isview">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isview</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isview" title="Permalink to this definition"></a></dt>
<dd><p>isview(thing) → boolean predicate, True if <cite>thing</cite> is any sort of mapping view instance – keys, values, or items</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isxlist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isxlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thinglist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isxlist" title="Permalink to this definition"></a></dt>
<dd><p>isxlist(predicate, thinglist) → boolean predicate, True if <cite>thinglist</cite> is a sequence of items, all of which match the predicate function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isxmetatypelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isxmetatypelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thinglist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isxmetatypelist" title="Permalink to this definition"></a></dt>
<dd><p>isxmetatypelist(predicate, thinglist) → boolean predicate, True if <cite>thinglist</cite> is a metatypelist, all types in which match the predicate function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.isxtypelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">isxtypelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">predicate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thinglist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.isxtypelist" title="Permalink to this definition"></a></dt>
<dd><p>isxtypelist(predicate, thinglist) → boolean predicate, True if <cite>thinglist</cite> is a typelist, all types in which match the predicate function</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.iterlen">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">iterlen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.iterlen" title="Permalink to this definition"></a></dt>
<dd><p>iterlen(iterable) → Return the number of items in “iterable.”</p>
<p>This will consume iterables without a “__len__()” method – be careful!</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.makemetatypelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">makemetatypelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.makemetatypelist" title="Permalink to this definition"></a></dt>
<dd><p>makemetatypelist(iterable) → convert an iterable of unknown things into a uniquified metatypelist – a list consisting only of metaclass types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.maketypelist">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">maketypelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">things</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.maketypelist" title="Permalink to this definition"></a></dt>
<dd><p>maketypelist(iterable) → convert an iterable of unknown things into a uniquified typelist – a list consisting only of class types</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.metaclasscheck">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">metaclasscheck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">putative</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">thinglist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.metaclasscheck" title="Permalink to this definition"></a></dt>
<dd><p>metaclasscheck(putative, <a href="#id101"><span class="problematic" id="id102">*</span></a>cls_or_tuple) → A wrapper for <cite>issubclass(…)</cite> and <cite>isinstance(…)</cite> that specifically inspects the metaclass of its primary operand</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.samelength">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">samelength</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.samelength" title="Permalink to this definition"></a></dt>
<dd><p>samelength(a, b) → boolean predicate, True if both <cite>len(a)</cite> and <cite>len(b)</cite> are defined and equal to each other</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.subclasscheck">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">subclasscheck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">putative</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">thinglist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology.subclasscheck" title="Permalink to this definition"></a></dt>
<dd><p>subclasscheck(putative, <a href="#id103"><span class="problematic" id="id104">*</span></a>cls_or_tuple) → A wrapper for <cite>issubclass(…)</cite> and <cite>isinstance(…)</cite> that tries to work with you</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.typology.">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">ΛΛ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.typology." title="Permalink to this definition"></a></dt>
<dd><p>ΛΛ(thing) → boolean predicate, True if <cite>thing</cite> is of a callable function type</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id105">
<span class="sig-prename descclassname"><span class="pre">clu.typology.</span></span><span class="sig-name descname"><span class="pre">λλ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id105" title="Permalink to this definition"></a></dt>
<dd><p>λλ(thing) → boolean predicate, True if <cite>thing</cite> is a function created with the «lambda» keyword</p>
</dd></dl>

</section>
<section id="module-clu.version">
<span id="clu-version"></span><h1>clu.version<a class="headerlink" href="#module-clu.version" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="clu.version.VersionAncestor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.version.</span></span><span class="sig-name descname"><span class="pre">VersionAncestor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">major</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">build</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.VersionAncestor" title="Permalink to this definition"></a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="clu.version.VersionAncestor.build">
<span class="sig-name descname"><span class="pre">build</span></span><a class="headerlink" href="#clu.version.VersionAncestor.build" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.version.VersionAncestor.major">
<span class="sig-name descname"><span class="pre">major</span></span><a class="headerlink" href="#clu.version.VersionAncestor.major" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.version.VersionAncestor.minor">
<span class="sig-name descname"><span class="pre">minor</span></span><a class="headerlink" href="#clu.version.VersionAncestor.minor" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.version.VersionAncestor.patch">
<span class="sig-name descname"><span class="pre">patch</span></span><a class="headerlink" href="#clu.version.VersionAncestor.patch" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="clu.version.VersionAncestor.pre">
<span class="sig-name descname"><span class="pre">pre</span></span><a class="headerlink" href="#clu.version.VersionAncestor.pre" title="Permalink to this definition"></a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="clu.version.VersionInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">clu.version.</span></span><span class="sig-name descname"><span class="pre">VersionInfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">major</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'‽'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'‽'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'‽'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'‽'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">build</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.VersionInfo" title="Permalink to this definition"></a></dt>
<dd><p>NamedTuple-descendant class allowing for convenient
and reasonably sane manipulation of semantic-version
(née “semver”) string-triple numberings, or whatever
the fuck is the technical term for them, erm. Yes!</p>
<dl class="py method">
<dt class="sig sig-object py" id="clu.version.VersionInfo.from_dict">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">version_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.VersionInfo.from_dict" title="Permalink to this definition"></a></dt>
<dd><p>Instantiate a VersionInfo with a dict of related values
(q.v. FIELD string names supra.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.version.VersionInfo.from_string">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">version_string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.VersionInfo.from_string" title="Permalink to this definition"></a></dt>
<dd><p>Instantiate a VersionInfo with a semver string</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.version.VersionInfo.to_dict">
<span class="sig-name descname"><span class="pre">to_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.VersionInfo.to_dict" title="Permalink to this definition"></a></dt>
<dd><p>Returns what you think it returns</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.version.VersionInfo.to_packaging_version">
<span class="sig-name descname"><span class="pre">to_packaging_version</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.VersionInfo.to_packaging_version" title="Permalink to this definition"></a></dt>
<dd><p>aka an instance of <cite>pkg_resources.extern.packaging.version.Version</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.version.VersionInfo.to_string">
<span class="sig-name descname"><span class="pre">to_string</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.VersionInfo.to_string" title="Permalink to this definition"></a></dt>
<dd><p>Return the VersionInfo data as a semver string</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="clu.version.VersionInfo.to_tuple">
<span class="sig-name descname"><span class="pre">to_tuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.VersionInfo.to_tuple" title="Permalink to this definition"></a></dt>
<dd><p>Return a complete tuple (as in, including “pre” and “build” fields)</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.version.comparator">
<span class="sig-prename descclassname"><span class="pre">clu.version.</span></span><span class="sig-name descname"><span class="pre">comparator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.comparator" title="Permalink to this definition"></a></dt>
<dd><p>Wrap a VersionInfo binary op method in a typechecker</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.version.compare_keys">
<span class="sig-prename descclassname"><span class="pre">clu.version.</span></span><span class="sig-name descname"><span class="pre">compare_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.compare_keys" title="Permalink to this definition"></a></dt>
<dd><p>Blatantly based on code from “semver”: <a class="reference external" href="https://git.io/fhb98">https://git.io/fhb98</a></p>
</dd></dl>

<span class="target" id="module-clu.version.git_version"></span><dl class="py function">
<dt class="sig sig-object py" id="clu.version.git_version.are_we_gitted">
<span class="sig-prename descclassname"><span class="pre">clu.version.git_version.</span></span><span class="sig-name descname"><span class="pre">are_we_gitted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.git_version.are_we_gitted" title="Permalink to this definition"></a></dt>
<dd><p>Check if we’re in a Git repo</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="clu.version.git_version.git_version_tags">
<span class="sig-prename descclassname"><span class="pre">clu.version.git_version.</span></span><span class="sig-name descname"><span class="pre">git_version_tags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.git_version.git_version_tags" title="Permalink to this definition"></a></dt>
<dd><p>Get the Git version tags</p>
</dd></dl>

<span class="target" id="module-clu.version.read_version"></span><p>Extract your project’s __version__ variable</p>
<p>When creating a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> for a new project, do you find yourself always
writing the same block of code for parsing <code class="docutils literal notranslate"><span class="pre">__version__</span></code> from your project’s
source?  Something like this?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;package_name&#39;</span><span class="p">,</span> <span class="s1">&#39;__init__.py&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\s*__version__\s*=\s*([</span><span class="se">\&#39;</span><span class="s1">&quot;])([^</span><span class="se">\&#39;</span><span class="s1">&quot;]+)\1\s*$&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">version</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unable to find own __version__ string&#39;</span><span class="p">)</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">version</span> <span class="o">=</span> <span class="n">version</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Someone needs to put all that into a reusable package, am I right?  Well,
someone did, and this is that package.</p>
<p>Visit &lt;<a class="reference external" href="https://github.com/jwodder/read_version">https://github.com/jwodder/read_version</a>&gt; for more information.</p>
<dl class="py function">
<dt class="sig sig-object py" id="clu.version.read_version.read_version">
<span class="sig-prename descclassname"><span class="pre">clu.version.read_version.</span></span><span class="sig-name descname"><span class="pre">read_version</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">fpath</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#clu.version.read_version.read_version" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">read_version()</span></code> takes one or more file path components pointing to a
Python source file to parse.  The path components will be joined together
with <code class="docutils literal notranslate"><span class="pre">os.path.join()</span></code>, and then, if the path isn’t absolute, the path to
the directory containing the script calling <code class="docutils literal notranslate"><span class="pre">read_version()</span></code> will be
prepended to the path.  (No more <code class="docutils literal notranslate"><span class="pre">join(dirname(__file__),</span> <span class="pre">...)</span></code>
boilerplate needed!)  <code class="docutils literal notranslate"><span class="pre">read_version()</span></code> then parses the given Python file
and searches through the parse tree for any assignments to a variable named
<code class="docutils literal notranslate"><span class="pre">__version__</span></code>, returning the last value assigned.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">variable</span></code> keyword argument can be set to the name of a variable
other than <code class="docutils literal notranslate"><span class="pre">__version__</span></code> to search for assignments to a different
variable instead.</p>
<p>If no assignments to the variable are found, a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is raised.
To instead return a default value when this happens, set the <code class="docutils literal notranslate"><span class="pre">default</span></code>
keyword argument.</p>
</dd></dl>

</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Alexander Böhn.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>